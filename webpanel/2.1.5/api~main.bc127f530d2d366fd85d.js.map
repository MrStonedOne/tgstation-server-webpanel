{"version":3,"sources":["webpack:///./src/ApiClient/generatedcode/_enums.ts","webpack:///./src/ApiClient/util/CredentialsProvider.ts","webpack:///./src/ApiClient/util/config.ts","webpack:///./src/ApiClient/util/ConfigController.ts","webpack:///./src/ApiClient/models/InternalComms/InternalStatus.ts","webpack:///./src/ApiClient/util/LoginHooks.ts","webpack:///./src/ApiClient/JobsClient.ts","webpack:///./src/ApiClient/util/JobsController.ts","webpack:///./src/ApiClient/UserClient.ts","webpack:///./src/ApiClient/models/ICredentials.ts","webpack:///./src/ApiClient/models/InternalComms/InternalError.ts","webpack:///./src/ApiClient/_base.ts","webpack:///./src/ApiClient/InstancePermissionSetClient.ts","webpack:///./src/ApiClient/ServerClient.ts"],"names":["AdministrationRights","ByondRights","ChatBotRights","ChatProvider","ConfigurationRights","ConfigurationType","DreamDaemonRights","DreamDaemonSecurity","DreamMakerRights","ErrorCode","InstanceManagerRights","InstancePermissionSetRights","OAuthProvider","RemoteGitProvider","RepositoryRights","RightsType","WatchdogStatus","token","credentials","MODE","window","credentialProvider","this","bearer","jobsWidgetOptions","configOptions","githubtoken","id","type","value","apipath","DEFAULT_APIPATH","jobpollinactive","jobpollactive","jobswidgetdisplay","possibleValues","AUTO","Object","values","val","getconfig","console","log","newconfig","entries","key","setconfig","option","undefined","deleteconfig","parseInt","Number","isNaN","callback","localStorage","setItem","JSON","stringify","e","data","getItem","json","parse","removeItem","StatusCode","InternalStatus","args","freeze","assign","LoginHooks","promiseHooks","Set","i","work","hook","name","push","Promise","resolve","reject","then","catch","err","error","all","emit","add","delete","TypedEmitter","instanceid","response","ServerClient","wait4Init","apiClient","JobController_Read","Instance","page","pageSize","stat","code","ERROR","status","OK","payload","content","InternalError","UNHANDLED_RESPONSE","axiosResponse","jobid","JobController_GetId","JOB_JOB_NOT_FOUND","errorMessage","JobController_Delete","JOB_JOB_COMPLETE","void","ApiClient","_instance","setInstance","fastmodecount","currentLoop","Date","errors","jobs","Map","loop","bind","reset","on","restartLoop","cycles","initDate","now","loopid","JobsClient","listActiveJobs","job","set","localids","Array","from","remoteids","map","manualids","filter","x","includes","getJob","length","progress","progressedjob","canCancel","setTimeout","HTTP_DATA_INEGRITY","originalErrorMessage","errorCode","TGSErrorCode","InstanceOffline","reason","cancelRightsType","Administration","userInfo","UserClient","getCurrentUser","required","cancelRight","resolvePermissionSet","administrationRights","InstanceManager","instanceManagerRights","Byond","InstancePermissionSet","InstancePermissionSetClient","getCurrentInstancePermissionSet","byondRights","ChatBots","chatBotRights","Configuration","configurationRights","DreamDaemon","dreamDaemonRights","DreamMaker","dreamMakerRights","instancePermissionSetRights","Repository","repositoryRights","onError","get","stoppedAt","APP_FAIL","jsError","Error","deleteInfo","deleteJob","_cachedUser","loadingUserInfo","createAllUsersWithAA","addHook","newUser","UserController_Update","current","USER_NOT_FOUND","bypassCache","resolver","user","removeListener","UserController_Read","res","thing","UserController_List","sort","a","b","UserController_GetId","newuser","enabled","perm","UserController_Create","USER_NO_SYS_IDENT","CredentialsType","DescType","addon","origin","desc","extendedInfo","TEXT","message","additionalData","stack","debuginfo","config","replace","CredentialsProvider","isTokenValid","replaceAll","breakonerror","clients","constructor","_cachedInstancePermissionSet","loadingInstancePermissionSetInfo","clear","has","InstancePermissionSetController_Read","api","initialized","loadingServerInfo","_serverInfo","autoLogin","loggingIn","getServerInfo","runHooks","initApi","location","reload","time","defObj","default","OpenAPIClientAxios","definition","axiosConfigDefaults","baseURL","withCredentials","headers","Accept","Api","API_VERSION","VERSION","validateStatus","globalHandledCodes","init","interceptors","request","use","errorobj","NO_APIPATH","url","tok","wait4Token","snowflake","AXIOS","HTTP_BAD_REQUEST","method","login","client","logout","HTTP_ACCESS_DENIED","HTTP_NOT_ACCEPTABLE","HTTP_API_MISMATCH","HTTP_SERVER_ERROR","HTTP_UNIMPLEMENTED","UNHANDLED_GLOBAL_RESPONSE","timeEnd","newCreds","oauthAutoLogin","OAuth","LOGIN_NOCREDS","info","Password","HomeController_CreateToken","auth","username","userName","password","provider","Authorization","LOGIN_FAIL","LOGIN_DISABLED","LOGIN_RATELIMIT","_token","HomeController_Home","cache"],"mappings":"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","file":"api~main.bc127f530d2d366fd85d.js","sourcesContent":["export enum AdministrationRights {\n   None = 0,\n   WriteUsers = 1,\n   RestartHost = 2,\n   ChangeVersion = 4,\n   EditOwnPassword = 8,\n   ReadUsers = 16,\n   DownloadLogs = 32,\n   EditOwnOAuthConnections = 64\n}\n\nexport enum ByondRights {\n   None = 0,\n   ReadActive = 1,\n   ListInstalled = 2,\n   InstallOfficialOrChangeActiveVersion = 4,\n   CancelInstall = 8,\n   InstallCustomVersion = 16\n}\n\nexport enum ChatBotRights {\n   None = 0,\n   WriteEnabled = 1,\n   WriteProvider = 2,\n   WriteChannels = 4,\n   WriteConnectionString = 8,\n   ReadConnectionString = 16,\n   Read = 32,\n   Create = 64,\n   Delete = 128,\n   WriteName = 256,\n   WriteReconnectionInterval = 512,\n   WriteChannelLimit = 1024\n}\n\nexport enum ChatProvider {\n   Irc = 0,\n   Discord = 1\n}\n\nexport enum ConfigurationRights {\n   None = 0,\n   Read = 1,\n   Write = 2,\n   List = 4,\n   Delete = 8\n}\n\nexport enum ConfigurationType {\n   Disallowed = 0,\n   HostWrite = 1,\n   SystemIdentityWrite = 2\n}\n\nexport enum DreamDaemonRights {\n   None = 0,\n   ReadRevision = 1,\n   SetPort = 2,\n   SetAutoStart = 4,\n   SetSecurity = 8,\n   ReadMetadata = 16,\n   SetWebClient = 32,\n   SoftRestart = 64,\n   SoftShutdown = 128,\n   Restart = 256,\n   Shutdown = 512,\n   Start = 1024,\n   SetStartupTimeout = 2048,\n   SetHeartbeatInterval = 4096,\n   CreateDump = 8192,\n   SetTopicTimeout = 16384,\n   SetAdditionalParameters = 32768\n}\n\nexport enum DreamDaemonSecurity {\n   Trusted = 0,\n   Safe = 1,\n   Ultrasafe = 2\n}\n\nexport enum DreamMakerRights {\n   None = 0,\n   Read = 1,\n   Compile = 2,\n   CancelCompile = 4,\n   SetDme = 8,\n   SetApiValidationPort = 16,\n   CompileJobs = 32,\n   SetSecurityLevel = 64,\n   SetApiValidationRequirement = 128\n}\n\nexport enum ErrorCode {\n   InternalServerError = 0,\n   ApiMismatch = 1,\n   ModelValidationFailure = 2,\n   IOError = 3,\n   BadHeaders = 4,\n   TokenWithToken = 5,\n   DatabaseIntegrityConflict = 6,\n   MissingHostWatchdog = 7,\n   CannotChangeServerSuite = 8,\n   RemoteApiError = 9,\n   ServerUpdateInProgress = 10,\n   UserNameChange = 11,\n   UserSidChange = 12,\n   UserMismatchNameSid = 13,\n   UserMismatchPasswordSid = 14,\n   UserPasswordLength = 15,\n   UserColonInName = 16,\n   UserMissingName = 17,\n   InstanceRelocateOnline = 18,\n   InstanceAtExistingPath = 19,\n   InstanceDetachOnline = 20,\n   InstanceAtConflictingPath = 21,\n   InstanceLimitReached = 22,\n   InstanceWhitespaceName = 23,\n   InstanceHeaderRequired = 24,\n   RequiresPosixSystemIdentity = 25,\n   ConfigurationFileUpdated = 26,\n   ConfigurationDirectoryNotEmpty = 27,\n   DEPRECATED_UnusedErrorCode1 = 28,\n   RepoMismatchUserAndAccessToken = 29,\n   RepoCloning = 30,\n   RepoBusy = 31,\n   RepoExists = 32,\n   RepoMissing = 33,\n   RepoMismatchShaAndReference = 34,\n   RepoMismatchShaAndUpdate = 35,\n   DEPRECATED_UnusedErrorCode2 = 36,\n   RepoDuplicateTestMerge = 37,\n   RepoWhitespaceCommitterName = 38,\n   RepoWhitespaceCommitterEmail = 39,\n   ApiPageTooLarge = 40,\n   ApiInvalidPageOrPageSize = 41,\n   ChatBotWrongChannelType = 42,\n   ChatBotWhitespaceConnectionString = 43,\n   ChatBotWhitespaceName = 44,\n   ChatBotProviderMissing = 45,\n   DEPRECATED_UnusedErrorCode3 = 46,\n   ChatBotMax = 47,\n   ChatBotMaxChannels = 48,\n   ByondDirectXInstallFail = 49,\n   ByondDownloadFail = 50,\n   ByondNoVersionsInstalled = 51,\n   DreamMakerNeverValidated = 52,\n   DreamMakerInvalidValidation = 53,\n   CannotRemoveLastAuthenticationOption = 54,\n   DreamMakerNoDme = 55,\n   DreamMakerMissingDme = 56,\n   DreamMakerExitCode = 57,\n   DreamMakerCompileJobInProgress = 58,\n   InstanceMissingDreamDaemonSettings = 59,\n   InstanceMissingDreamMakerSettings = 60,\n   InstanceMissingRepositorySettings = 61,\n   InstanceUpdateTestMergeConflict = 62,\n   RepoCredentialsRequired = 63,\n   RepoCannotAuthenticate = 64,\n   RepoReferenceRequired = 65,\n   WatchdogRunning = 66,\n   WatchdogCompileJobCorrupted = 67,\n   WatchdogStartupFailed = 68,\n   WatchdogStartupTimeout = 69,\n   RepoUnsupportedTestMergeRemote = 70,\n   RepoSwappedShaOrReference = 71,\n   RepoMergeConflict = 72,\n   RepoReferenceNotTracking = 73,\n   RepoTestMergeConflict = 74,\n   InstanceNotAtWhitelistedPath = 75,\n   DreamDaemonDoubleSoft = 76,\n   DeploymentPagerRunning = 77,\n   DreamDaemonPortInUse = 78,\n   PostDeployFailure = 79,\n   WatchdogNotRunning = 80,\n   ResourceNotPresent = 81,\n   ResourceNeverPresent = 82,\n   GitHubApiRateLimit = 83,\n   JobStopped = 84,\n   MissingGCore = 85,\n   GCoreFailure = 86,\n   RepoTestMergeInvalidRemote = 87,\n   ByondNonExistentCustomVersion = 88,\n   DreamDaemonOffline = 89,\n   InstanceOffline = 90,\n   ChatCannotConnectProvider = 91,\n   ByondDreamDaemonFirewallFail = 92,\n   NoPortsAvailable = 93,\n   PortNotAvailable = 94,\n   AdminUserCannotOAuth = 95,\n   OAuthProviderDisabled = 96,\n   FileUploadExpired = 97,\n   UserGroupAndPermissionSet = 98,\n   UserGroupNotEmpty = 99,\n   UserLimitReached = 100,\n   UserGroupLimitReached = 101\n}\n\nexport enum InstanceManagerRights {\n   None = 0,\n   Read = 1,\n   Create = 2,\n   Rename = 4,\n   Relocate = 8,\n   SetOnline = 16,\n   Delete = 32,\n   List = 64,\n   SetConfiguration = 128,\n   SetAutoUpdate = 256,\n   SetChatBotLimit = 512,\n   GrantPermissions = 1024\n}\n\nexport enum InstancePermissionSetRights {\n   None = 0,\n   Read = 1,\n   Write = 2,\n   Create = 4\n}\n\nexport enum OAuthProvider {\n   GitHub = \"GitHub\",\n   Discord = \"Discord\",\n   TGForums = \"TGForums\",\n   Keycloak = \"Keycloak\"\n}\n\nexport enum RemoteGitProvider {\n   Unknown = 0,\n   GitHub = 1,\n   GitLab = 2\n}\n\nexport enum RepositoryRights {\n   None = 0,\n   CancelPendingChanges = 1,\n   SetOrigin = 2,\n   SetSha = 4,\n   MergePullRequest = 8,\n   UpdateBranch = 16,\n   ChangeCommitter = 32,\n   ChangeTestMergeCommits = 64,\n   ChangeCredentials = 128,\n   SetReference = 256,\n   Read = 512,\n   ChangeAutoUpdateSettings = 1024,\n   Delete = 2048,\n   CancelClone = 4096\n}\n\nexport enum RightsType {\n   Administration = 0,\n   InstanceManager = 1,\n   Repository = 2,\n   Byond = 3,\n   DreamMaker = 4,\n   DreamDaemon = 5,\n   ChatBots = 6,\n   Configuration = 7,\n   InstancePermissionSet = 8\n}\n\nexport enum WatchdogStatus {\n   Offline = 0,\n   Restoring = 1,\n   Online = 2,\n   DelayedRestart = 3\n}\n\n","import { MODE } from \"../../definitions/constants\";\nimport { Components } from \"../generatedcode/_generated\";\nimport { ICredentials } from \"../models/ICredentials\";\n\n//Data structure meant to help against circular dependencies within the ApiClient\n//Its rather dumb and only holds username, password and the token.\n//Also contains a function to determine if theres a token here\nexport default new (class CredentialsProvider {\n    //token\n    public token?: Components.Schemas.TokenResponse;\n\n    //credentials\n    public credentials?: ICredentials;\n\n    public isTokenValid() {\n        return (\n            this.credentials &&\n            this.token &&\n            this.token\n                .bearer /* &&\n            (!this.token.expiresAt || new Date(this.token.expiresAt) > new Date(Date.now()))*/\n        );\n    }\n\n    public constructor() {\n        if (MODE === \"DEV\") {\n            window.credentialProvider = this;\n        }\n    }\n})();\n","import { DEFAULT_APIPATH } from \"../../definitions/constants\";\n\nexport type ConfigValue = number | string | boolean;\n\nexport type ConfigOption = BaseConfigOption &\n    (NumConfigOption | StrConfigOption | PwdConfigOption | BoolConfigOption | EnumConfigOption);\n\nexport interface BaseConfigOption {\n    id: string;\n}\n\nexport interface NumConfigOption extends BaseConfigOption {\n    type: \"num\";\n    value: number;\n    callback?: (oldValue: number, newValue: number) => void;\n}\nexport interface StrConfigOption extends BaseConfigOption {\n    type: \"str\";\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\nexport interface PwdConfigOption extends BaseConfigOption {\n    type: \"pwd\";\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\nexport interface BoolConfigOption extends BaseConfigOption {\n    type: \"bool\";\n    value: boolean;\n    callback?: (oldValue: boolean, newValue: boolean) => void;\n}\nexport interface EnumConfigOption extends BaseConfigOption {\n    type: \"enum\";\n    possibleValues: Record<string, string>;\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\n\nexport type ConfigMap = {\n    [key: string]: ConfigOption;\n};\n\nexport enum jobsWidgetOptions {\n    ALWAYS = \"always\",\n    AUTO = \"auto\",\n    NEVER = \"never\"\n}\n\nconst configOptions: ConfigMap = {\n    githubtoken: {\n        id: \"config.githubtoken\",\n        type: \"pwd\",\n        value: \"\"\n    },\n    apipath: {\n        id: \"config.apipath\",\n        type: \"str\",\n        value: DEFAULT_APIPATH\n    },\n    jobpollinactive: {\n        id: \"config.jobpollinactive\",\n        type: \"num\",\n        value: 15\n    },\n    jobpollactive: {\n        id: \"config.jobpollactive\",\n        type: \"num\",\n        value: 5\n    },\n    jobswidgetdisplay: {\n        id: \"config.jobswidgetdisplay\",\n        type: \"enum\",\n        possibleValues: jobsWidgetOptions,\n        value: jobsWidgetOptions.AUTO\n    }\n};\n\nexport default configOptions;\n","import configOptions, { ConfigOption, ConfigValue } from \"./config\";\n\nexport default new (class ConfigController {\n    public loadconfig() {\n        for (const val of Object.values(configOptions)) {\n            this.getconfig(val);\n        }\n        console.log(\"Configuration loaded\", configOptions);\n    }\n\n    public saveconfig(newconfig: { [key: string]: ConfigOption }) {\n        for (const [key, val] of Object.entries(newconfig)) {\n            this.setconfig(key, val);\n        }\n        console.log(\"Configuration saved\", configOptions);\n    }\n\n    private setconfig(key: string, option: ConfigOption) {\n        if (option?.value === undefined) return this.deleteconfig(key);\n\n        //safeties\n        switch (option.type) {\n            case \"num\":\n                //this parses strings and numbers alike to numbers and refuses non numbers\n                //@ts-expect-error //parseInt can take numbers\n                option.value = parseInt(option.value);\n                if (Number.isNaN(option.value)) return;\n                break;\n        }\n\n        if (option.callback) {\n            // @ts-expect-error Can't be assed to figure this one out\n            option.callback(configOptions[key].value, option.value);\n        }\n        configOptions[key].value = option.value;\n        //configOptions[key].persist = option.persist;\n\n        //if (!option.persist) return this.deleteconfig(key); //idiot proofing, alexkar proofing\n\n        try {\n            localStorage.setItem(option.id, JSON.stringify(option.value));\n            //option.persist = true;\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n\n    private getconfig(option: ConfigOption): void {\n        try {\n            const data = localStorage.getItem(option.id);\n            if (data !== undefined && data !== null) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const json = JSON.parse(data);\n                if (json !== null && json !== undefined) {\n                    option.value = json as ConfigValue;\n                }\n                //option.persist = true;\n            }\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n\n    private deleteconfig(key: string): void {\n        try {\n            const option = configOptions[key];\n            localStorage.removeItem(option.id);\n            //option.persist = false;\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n})();\n","import InternalError, { ErrorCode } from \"./InternalError\";\n\nexport enum StatusCode {\n    OK,\n    ERROR\n}\n\nexport interface InternalStatusErr<Codes extends ErrorCode> {\n    code: StatusCode.ERROR;\n    error: InternalError<Codes>;\n}\n\nexport interface InternalStatusOK<T> {\n    code: StatusCode.OK;\n    payload: T;\n}\n\ntype InternalStatus<T, Codes extends ErrorCode> = InternalStatusOK<T> | InternalStatusErr<Codes>;\n\nconst InternalStatus = (function InternalStatus<T, Codes extends ErrorCode>(\n    this: InternalStatus<T, Codes>,\n    args: InternalStatus<T, Codes>\n): Readonly<InternalStatus<T, Codes>> {\n    return Object.freeze(Object.assign({}, args));\n} as unknown) as {\n    new <T, Codes extends ErrorCode>(args: InternalStatus<T, Codes>): Readonly<\n        InternalStatus<T, Codes>\n    >;\n};\n\nexport default InternalStatus;\n","import { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { Components } from \"../generatedcode/_generated\";\n\ninterface IEvents {\n    //tasks once the user is fully logged in\n    loginSuccess: (token: Components.Schemas.TokenResponse) => void;\n}\n\nclass LoginHooks extends TypedEmitter<IEvents> {\n    private promiseHooks: Set<\n        (token: Components.Schemas.TokenResponse) => Promise<unknown>\n    > = new Set();\n\n    public runHooks(token: Components.Schemas.TokenResponse) {\n        console.log(\"Running login hooks\");\n        let i = 0;\n        const work: Array<Promise<void>> = [];\n        for (const hook of this.promiseHooks) {\n            const id = i;\n            console.log(`Running hook ${hook.name}(${id})`);\n            work.push(\n                new Promise<void>((resolve, reject) => {\n                    hook(token)\n                        .then(() => {\n                            console.log(`Done hook ${hook.name}(${id})`);\n                            resolve();\n                        })\n                        .catch(err => {\n                            console.error(`Error running hook ${hook.name}(${id}): `, err);\n                            reject(err);\n                        });\n                })\n            );\n            i++;\n        }\n        Promise.all(work)\n            .then(() => {\n                console.log(\"Running post login event\");\n                this.emit(\"loginSuccess\", token);\n            })\n            .catch(() => console.error(\"An error occured while running login hooks\"));\n    }\n\n    public addHook(hook: (token: Components.Schemas.TokenResponse) => Promise<unknown>): void {\n        this.promiseHooks.add(hook);\n    }\n\n    public removeHook(hook: (token: Components.Schemas.TokenResponse) => Promise<unknown>): void {\n        this.promiseHooks.delete(hook);\n    }\n}\n\nexport default new LoginHooks();\n","import { ApiClient } from \"./_base\";\nimport { Components } from \"./generatedcode/_generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\nexport type listJobsErrors = GenericErrors;\nexport type getJobErrors = GenericErrors | ErrorCode.JOB_JOB_NOT_FOUND;\nexport type deleteJobErrors =\n    | GenericErrors\n    | ErrorCode.JOB_JOB_NOT_FOUND\n    | ErrorCode.JOB_JOB_COMPLETE;\n\nexport default new (class JobsClient extends ApiClient {\n    public async listActiveJobs(\n        instanceid: number\n    ): Promise<InternalStatus<Components.Schemas.JobResponse[], listJobsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_Read({\n                Instance: instanceid,\n                page: 1,\n                pageSize: 100\n            });\n        } catch (stat) {\n            return new InternalStatus<Components.Schemas.JobResponse[], listJobsErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus<Components.Schemas.JobResponse[], listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: (response.data as Components.Schemas.PaginatedJobResponse)!.content\n                });\n            }\n            default: {\n                return new InternalStatus<Components.Schemas.JobResponse[], listJobsErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<Components.Schemas.JobResponse, getJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_GetId({\n                Instance: instanceid,\n                id: jobid\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.JobResponse\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as Components.Schemas.ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async deleteJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<Components.Schemas.JobResponse, deleteJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_Delete({\n                Instance: instanceid,\n                id: jobid\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.JobResponse\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as Components.Schemas.ErrorMessageResponse\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_COMPLETE, {\n                        void: true\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { resolvePermissionSet } from \"../../utils/misc\";\nimport {\n    AdministrationRights,\n    ByondRights,\n    ChatBotRights,\n    ConfigurationRights,\n    DreamDaemonRights,\n    DreamMakerRights,\n    ErrorCode as TGSErrorCode,\n    InstanceManagerRights,\n    InstancePermissionSetRights,\n    RepositoryRights,\n    RightsType\n} from \"../generatedcode/_enums\";\nimport { Components } from \"../generatedcode/_generated\";\nimport InstancePermissionSetClient from \"../InstancePermissionSetClient\";\nimport JobsClient, { getJobErrors, listJobsErrors } from \"../JobsClient\";\nimport InternalError, { ErrorCode } from \"../models/InternalComms/InternalError\";\nimport { StatusCode } from \"../models/InternalComms/InternalStatus\";\nimport ServerClient from \"../ServerClient\";\nimport UserClient from \"../UserClient\";\nimport configOptions from \"./config\";\n\ninterface IEvents {\n    jobsLoaded: () => unknown;\n}\n\nexport type CanCancelJob = Components.Schemas.JobResponse & {\n    canCancel?: boolean;\n};\n\nexport default new (class JobsController extends TypedEmitter<IEvents> {\n    private _instance: number | undefined;\n    public set instance(id: number | undefined) {\n        this._instance = id;\n        this.reset();\n    }\n\n    //This is a special property that gets set by approutes to add a handler for when this needs to change the instance\n    // This is here as a hack so that JobsController doesnt have to reference files outside the api client\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    public setInstance: (instance: number | undefined) => void = () => {};\n\n    private fastmodecount = 0;\n    public set fastmode(cycles: number) {\n        console.log(`JobsController going in fastmode for ${cycles} cycles`);\n        this.fastmodecount = cycles;\n        this.restartLoop();\n    }\n\n    private currentLoop: Date = new Date(0);\n\n    public errors: InternalError<getJobErrors | listJobsErrors>[] = [];\n    public jobs: Map<number, Components.Schemas.JobResponse> = new Map<\n        number,\n        Components.Schemas.JobResponse\n    >();\n\n    private reset() {\n        this.jobs = new Map<number, Components.Schemas.JobResponse>();\n        this.restartLoop();\n    }\n\n    public constructor() {\n        super();\n\n        this.loop = this.loop.bind(this);\n        this.reset = this.reset.bind(this);\n\n        //technically not a \"cache\" but we might as well reload it\n        ServerClient.on(\"purgeCache\", this.reset);\n    }\n\n    public restartLoop() {\n        //we use an actual date object here because it could help prevent really weird timing\n        // issues as two different date objects cannot be equal\n        // despite the date being\n        const initDate = new Date(Date.now());\n        this.currentLoop = initDate;\n        this.loop(initDate);\n    }\n\n    private loop(loopid: Date) {\n        //if we dont got an instance to check, dont check\n        // normally we should have an instance id, but this is in case we dont\n        if (this._instance === undefined) {\n            return;\n        }\n\n        //so loops get initialiazed with the current time, it keeps track of which loop to run with\n        // that initialization date in currentLoop if the currentLoop isnt equal to the one provided\n        // to the loop, it means that the loop was\n        // replaced so we dont try to call for another one\n        if (loopid !== this.currentLoop) {\n            return;\n        }\n\n        //time to clear out errors\n        this.errors = [];\n\n        //now since this is async, it still possible that a single fire gets done after the new loop started, theres no really much that can be done about it\n        JobsClient.listActiveJobs(this._instance)\n            .then(async value => {\n                //this check is here because the request itself is async and could return after\n                // the loop is terminated, we dont want to contaminate the jobs of an instance\n                // with the jobs of another even if it is for a single fire and would eventually\n                // get fixed on its own after a few seconds\n                if (loopid !== this.currentLoop) return;\n\n                if (value.code === StatusCode.OK) {\n                    for (const job of value.payload) {\n                        this.jobs.set(job.id, job);\n                    }\n\n                    //we check all jobs we have locally against the active jobs we got in the reply so\n                    // we can query jobs which we didnt get informed about manually\n                    const localids = Array.from(this.jobs, ([, job]) => job.id);\n                    const remoteids = value.payload.map(job => job.id);\n\n                    const manualids = localids.filter(x => !remoteids.includes(x));\n\n                    const work: Promise<void>[] = [];\n                    for (const id of manualids) {\n                        work.push(\n                            JobsClient.getJob(this._instance!, id).then(status => {\n                                if (loopid !== this.currentLoop) return;\n\n                                if (status.code === StatusCode.OK) {\n                                    this.jobs.set(id, status.payload);\n                                } else {\n                                    this.errors.push(status.error);\n                                }\n                            })\n                        );\n                    }\n                    //await all jobs to exist\n                    await Promise.all(work);\n\n                    if (loopid !== this.currentLoop) return;\n\n                    work.length = 0;\n                    for (const _job of this.jobs.values()) {\n                        const job = _job as CanCancelJob;\n                        if (job.progress === undefined) {\n                            work.push(\n                                JobsClient.getJob(this._instance!, job.id).then(progressedjob => {\n                                    if (loopid !== this.currentLoop) return;\n                                    if (progressedjob.code === StatusCode.OK) {\n                                        job.progress = progressedjob.payload.progress;\n                                    } else {\n                                        this.errors.push(progressedjob.error);\n                                    }\n                                })\n                            );\n                        }\n\n                        work.push(\n                            this.canCancel(job, this.errors).then(canCancel => {\n                                if (loopid !== this.currentLoop) return;\n                                job.canCancel = canCancel;\n                            })\n                        );\n                    }\n\n                    //populate fields on jobs\n                    await Promise.all(work);\n\n                    if (loopid !== this.currentLoop) return;\n\n                    if (this.fastmodecount && loopid === this.currentLoop) {\n                        window.setTimeout(() => this.loop(loopid), 800);\n                        this.fastmodecount--;\n                        console.log(\n                            `JobsController will remain in fastmode for ${this.fastmodecount} cycles`\n                        );\n                    } else {\n                        window.setTimeout(\n                            () => this.loop(loopid),\n                            (value.payload.length\n                                ? (configOptions.jobpollactive.value as number)\n                                : (configOptions.jobpollinactive.value as number)) * 1000\n                        );\n                    }\n                } else {\n                    if (\n                        value.error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                        value.error.originalErrorMessage?.errorCode === TGSErrorCode.InstanceOffline\n                    ) {\n                        console.log(\"[JobsController] Clearing instance as it is now offline\");\n                        this.setInstance(undefined);\n                    }\n                    this.errors.push(value.error);\n                    window.setTimeout(() => this.loop(loopid), 10000);\n                }\n\n                this.emit(\"jobsLoaded\");\n            })\n            .catch(reason => {\n                console.error(reason);\n            });\n    }\n\n    private async canCancel(\n        job: Readonly<CanCancelJob>,\n        errors: InternalError<ErrorCode>[]\n    ): Promise<boolean> {\n        //shouldnt really occur in normal conditions but this is a safety anyways\n        if (this._instance === undefined) return false;\n\n        //we dont need to reevalutate stuff that we already know\n        if (job.canCancel !== undefined) return job.canCancel;\n\n        if (job.cancelRightsType === undefined) {\n            return true;\n        }\n\n        switch (job.cancelRightsType as RightsType) {\n            case RightsType.Administration: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as AdministrationRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).administrationRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.InstanceManager: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstanceManagerRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).instanceManagerRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.Byond: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ByondRights;\n                    return !!(InstancePermissionSet.payload.byondRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.ChatBots: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ChatBotRights;\n                    return !!(InstancePermissionSet.payload.chatBotRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Configuration: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ConfigurationRights;\n                    return !!(InstancePermissionSet.payload.configurationRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamDaemon: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamDaemonRights;\n                    return !!(InstancePermissionSet.payload.dreamDaemonRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamMaker: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamMakerRights;\n                    return !!(InstancePermissionSet.payload.dreamMakerRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.InstancePermissionSet: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstancePermissionSetRights;\n                    return !!(InstancePermissionSet.payload.instancePermissionSetRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Repository: {\n                const InstancePermissionSet = await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    this._instance\n                );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as RepositoryRights;\n                    return !!(InstancePermissionSet.payload.repositoryRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n        }\n    }\n\n    public async cancelOrClear(\n        jobid: number,\n        onError: (error: InternalError<ErrorCode>) => void\n    ): Promise<boolean> {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        //just clear out the job\n        if (job.stoppedAt) {\n            this.jobs.delete(jobid);\n            return true;\n        } else {\n            if (this._instance === undefined) {\n                onError(\n                    new InternalError(ErrorCode.APP_FAIL, {\n                        jsError: new Error(\"No instance selected during deletion of a job\")\n                    })\n                );\n                return false;\n            } else {\n                const deleteInfo = await JobsClient.deleteJob(this._instance, jobid);\n                if (deleteInfo.code === StatusCode.OK) {\n                    return true;\n                } else {\n                    onError(deleteInfo.error);\n                    return false;\n                }\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport { AdministrationRights, InstanceManagerRights } from \"./generatedcode/_enums\";\nimport { Components } from \"./generatedcode/_generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport LoginHooks from \"./util/LoginHooks\";\n\ninterface IEvents {\n    loadUserInfo: (user: InternalStatus<Components.Schemas.UserResponse, GenericErrors>) => void;\n}\n\nexport type EditUserErrors = GenericErrors | ErrorCode.USER_NOT_FOUND;\nexport type GetUserErrors = GenericErrors | ErrorCode.USER_NOT_FOUND;\nexport type CreateUserErrors = GenericErrors | ErrorCode.USER_NO_SYS_IDENT;\n\nexport default new (class UserClient extends ApiClient<IEvents> {\n    private _cachedUser?: InternalStatus<Components.Schemas.UserResponse, ErrorCode.OK>;\n    public get cachedUser() {\n        return this._cachedUser;\n    }\n    private loadingUserInfo = false;\n    //If set to true, all created users will default to having all permissions granted, used by the setup\n    public createAllUsersWithAA = false;\n\n    public constructor() {\n        super();\n        this.getCurrentUser = this.getCurrentUser.bind(this);\n\n        LoginHooks.addHook(() => this.getCurrentUser());\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedUser = undefined;\n        });\n    }\n\n    public async editUser(\n        newUser: Components.Schemas.UserUpdateRequest\n    ): Promise<InternalStatus<Components.Schemas.UserResponse, EditUserErrors>> {\n        await ServerClient.wait4Init();\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_Update(null, newUser);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<EditUserErrors>\n            });\n        }\n        // noinspection DuplicatedCode\n        switch (response.status) {\n            case 200: {\n                const current = await this.getCurrentUser();\n                if (current.code == StatusCode.OK) {\n                    if (current.payload.id == newUser.id) {\n                        //if we are editing ourselves, clear cached data to reload permissions on the app\n                        ServerClient.emit(\"purgeCache\");\n                    }\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: current.error\n                    });\n                }\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.UserResponse\n                });\n            }\n            case 404: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NOT_FOUND, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getCurrentUser(\n        bypassCache?: boolean\n    ): Promise<InternalStatus<Components.Schemas.UserResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n        if (this._cachedUser && !bypassCache) {\n            return this._cachedUser;\n        }\n\n        if (this.loadingUserInfo) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<Components.Schemas.UserResponse, GenericErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadUserInfo\", resolver);\n                };\n                this.on(\"loadUserInfo\", resolver);\n            });\n        }\n\n        this.loadingUserInfo = true;\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_Read();\n        } catch (stat) {\n            const res = new InternalStatus<Components.Schemas.UserResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadUserInfo\", res);\n            this.loadingUserInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<Components.Schemas.UserResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.UserResponse\n                });\n\n                this._cachedUser = thing;\n                this.emit(\"loadUserInfo\", thing);\n                this.loadingUserInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<\n                    Components.Schemas.UserResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadUserInfo\", res);\n                this.loadingUserInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async listUsers(): Promise<\n        InternalStatus<Components.Schemas.UserResponse[], GenericErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_List({\n                page: 1,\n                pageSize: 100\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const payload = (response.data as Components.Schemas.PaginatedUserResponse)!.content.sort(\n                    (a, b) => a.id - b.id\n                );\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getUser(\n        id: number\n    ): Promise<InternalStatus<Components.Schemas.UserResponse, GetUserErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_GetId({ id: id });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        // noinspection DuplicatedCode\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.UserResponse\n                });\n            }\n            case 404: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NOT_FOUND, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createUser(\n        newuser:\n            | {\n                  name: string;\n                  password: string;\n                  enabled?: boolean;\n                  instanceManagerRights?: InstanceManagerRights;\n                  administrationRights?: AdministrationRights;\n              }\n            | {\n                  systemIdentifier: string;\n                  enabled?: boolean;\n                  instanceManagerRights?: InstanceManagerRights;\n                  administrationRights?: AdministrationRights;\n              }\n    ): Promise<InternalStatus<Components.Schemas.UserResponse, CreateUserErrors>> {\n        await ServerClient.wait4Init();\n\n        if (newuser.enabled === undefined) newuser.enabled = true;\n        if (this.createAllUsersWithAA) {\n            newuser.instanceManagerRights = 0;\n            newuser.administrationRights = 0;\n\n            for (const perm of Object.values(InstanceManagerRights)) {\n                if (typeof perm !== \"number\") continue;\n                newuser.instanceManagerRights += perm;\n            }\n\n            for (const perm of Object.values(AdministrationRights)) {\n                if (typeof perm !== \"number\") continue;\n                newuser.administrationRights += perm;\n            }\n        }\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_Create(\n                null,\n                newuser as Components.Schemas.UserCreateRequest\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 201: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.UserResponse\n                });\n            }\n            case 410: {\n                const errorMessage = response.data as Components.Schemas.ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NO_SYS_IDENT, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { OAuthProvider } from \"../generatedcode/_enums\";\n\nexport enum CredentialsType {\n    Password,\n    OAuth\n}\n\nexport interface IPasswordCredentials {\n    type: CredentialsType.Password;\n    userName: string;\n    password: string;\n}\n\nexport interface IOAuthCredentials {\n    type: CredentialsType.OAuth;\n    provider: OAuthProvider;\n    token: string;\n}\n\nexport type ICredentials = IPasswordCredentials | IOAuthCredentials;\n","import { AxiosResponse } from \"axios\";\n\nimport { replaceAll } from \"../../../utils/misc\";\nimport { ErrorCode as TGSErrorCode } from \"../../generatedcode/_enums\";\nimport { Components } from \"../../generatedcode/_generated\";\nimport configOptions from \"../../util/config\";\nimport CredentialsProvider from \"../../util/CredentialsProvider\";\n\nexport type GenericErrors =\n    | ErrorCode.HTTP_BAD_REQUEST\n    | ErrorCode.HTTP_DATA_INEGRITY\n    | ErrorCode.HTTP_API_MISMATCH\n    | ErrorCode.HTTP_SERVER_ERROR\n    | ErrorCode.HTTP_UNIMPLEMENTED\n    //    | ErrorCode.HTTP_SERVER_NOT_READY\n    | ErrorCode.AXIOS\n    | ErrorCode.UNHANDLED_RESPONSE\n    | ErrorCode.UNHANDLED_GLOBAL_RESPONSE\n    | ErrorCode.HTTP_ACCESS_DENIED\n    | ErrorCode.HTTP_NOT_ACCEPTABLE\n    | ErrorCode.OK\n    | ErrorCode.NO_APIPATH\n    | ErrorCode.APP_FAIL;\n\nexport enum ErrorCode {\n    OK = 'Isnt displayed but is used as an \"error\" when everything is ok', //void\n    HTTP_BAD_REQUEST = \"error.http.bad_request\", //errmessage\n    HTTP_DATA_INEGRITY = \"error.http.data_integrity\", //errmessage\n    HTTP_API_MISMATCH = \"error.http.api_mismatch\", //void\n    HTTP_SERVER_ERROR = \"error.http.server_error\", //errmessage\n    HTTP_UNIMPLEMENTED = \"error.http.unimplemented\", //errmessage\n    //auto retry    HTTP_SERVER_NOT_READY = 'error.http.server_not_ready', //void\n    HTTP_ACCESS_DENIED = \"error.http.access_denied\", //void\n    HTTP_NOT_ACCEPTABLE = \"error.http.not_acceptable\", //void\n    UNHANDLED_RESPONSE = \"error.unhandled_response\", //axiosresponse\n    UNHANDLED_GLOBAL_RESPONSE = \"error.unhandled_global_response\", //axiosresponse\n    AXIOS = \"error.axios\", //jserror\n\n    //Generic errors\n    GITHUB_FAIL = \"error.github\", //jserror\n    APP_FAIL = \"error.app\", //jserror\n    NO_APIPATH = \"error.no_apipath\", //void\n\n    //Login errors\n    LOGIN_FAIL = \"error.login.bad_user_pass\", //void\n    LOGIN_NOCREDS = \"error.login.no_creds\", //void\n    LOGIN_DISABLED = \"error.login.user_disabled\", //void\n    LOGIN_BAD_OAUTH = \"error.login.bad_oauth\", //jserror\n    LOGIN_RATELIMIT = \"error.login.rate_limit\", //errmessage\n\n    //User errors\n    USER_NO_SYS_IDENT = \"error.user.no_sys_ident\", //errmessage\n    USER_NOT_FOUND = \"error.user.not_found\", //errmessage\n\n    //Administration errors\n    ADMIN_GITHUB_RATE = \"error.admin.rate\", //errmessage\n    ADMIN_GITHUB_ERROR = \"error.admin.error\", //errmessage\n    ADMIN_WATCHDOG_UNAVAIL = \"error.admin.watchdog.avail\", //errmessage\n    ADMIN_VERSION_NOT_FOUND = \"error.admin.update.notfound\", //errmessage\n    ADMIN_LOGS_IO_ERROR = \"error.admin.logs.io\", //errmessage\n\n    //Job errors\n    JOB_JOB_NOT_FOUND = \"error.job.not_found\", //errmessage\n    JOB_JOB_COMPLETE = \"error.job.complete\", //void\n\n    //Transfer errors\n    TRANSFER_NOT_AVAILABLE = \"error.transfer.not_available\", //errmessage\n    UPLOAD_FAILED = \"error.transfer.upload_failed\", //void\n\n    GROUP_NOT_FOUND = \"error.group.not_found\", //errmessage\n    GROUP_NOT_EMPTY = \"error.group.not_empty\", //errmessage\n\n    //Instance errors\n    INSTANCE_NO_DB_ENTITY = \"error.instance.no_db_entity\" //errmessage\n}\n\ntype errorMessage = {\n    errorMessage: Components.Schemas.ErrorMessageResponse;\n};\ntype axiosResponse = {\n    axiosResponse: AxiosResponse;\n};\ntype jsError = {\n    jsError: Error;\n};\ntype voidError = {\n    void: true;\n};\n\nexport enum DescType {\n    LOCALE,\n    TEXT\n}\ninterface Desc {\n    type: DescType;\n    desc: string;\n}\n\ntype allAddons = errorMessage | axiosResponse | jsError | voidError;\n\nexport default class InternalError<T extends ErrorCode> {\n    public readonly code: T;\n    public readonly desc?: Desc;\n    public readonly extendedInfo: string;\n    public readonly originalErrorMessage?: Components.Schemas.ErrorMessageResponse;\n\n    public constructor(code: T, addon: allAddons, origin?: AxiosResponse) {\n        this.code = code;\n        if (\"errorMessage\" in addon) {\n            const err = addon.errorMessage;\n            this.originalErrorMessage = err;\n            this.desc = {\n                type: DescType.TEXT,\n                desc:\n                    TGSErrorCode[err.errorCode] +\n                    \": \" +\n                    err.message +\n                    (err.additionalData ? \": \" + err.additionalData : \"\")\n            };\n            if (!err.message) {\n                this.desc = {\n                    type: DescType.TEXT,\n                    desc: TGSErrorCode[err.errorCode]\n                };\n            }\n        }\n        if (\"jsError\" in addon) {\n            const err = addon.jsError;\n            this.desc = {\n                type: DescType.TEXT,\n                desc: `${err.name}: ${err.message}`\n            };\n        }\n        const stack = new Error().stack;\n\n        let debuginfo = JSON.stringify({ addon, origin, config: configOptions, stack });\n        debuginfo = debuginfo.replace(\n            /Basic (?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?/g,\n            \"Basic **************\"\n        );\n        debuginfo = debuginfo.replace(\n            /{\"username\":\".+?\",\"password\":\".+?\"}/g,\n            '{\"username\":\"*******\",\"password\":\"*******\"}'\n        );\n        if (CredentialsProvider.isTokenValid()) {\n            debuginfo = replaceAll(\n                debuginfo,\n                CredentialsProvider.token?.bearer as string,\n                \"**************\"\n            );\n        }\n        if (configOptions.githubtoken.value) {\n            debuginfo = replaceAll(\n                debuginfo,\n                configOptions.githubtoken.value as string,\n                \"**************\"\n            );\n        }\n        this.extendedInfo = debuginfo;\n\n        console.error(\n            `Error occured within the application: ${this.code} (${\n                this.desc?.desc || \"No description\"\n            })`,\n            this\n        );\n\n        //@ts-expect-error yeah well, i aint extending the window interface\n        if (window.breakonerror) {\n            // eslint-disable-next-line no-debugger\n            debugger;\n        }\n    }\n}\n","import { DefaultListener, ListenerSignature, TypedEmitter } from \"tiny-typed-emitter\";\n\nexport abstract class ApiClient<\n    L extends ListenerSignature<L> = DefaultListener\n> extends TypedEmitter<L> {\n    public constructor() {\n        super();\n        if (window.clients == undefined) window.clients = {};\n        console.log(this.constructor.name, this);\n        window.clients[this.constructor.name] = this;\n    }\n}\n","import { ApiClient } from \"./_base\";\nimport { Components } from \"./generatedcode/_generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\ninterface IEvents {\n    loadInstancePermissionSet: (\n        user: InternalStatus<Components.Schemas.InstancePermissionSetResponse, GenericErrors>\n    ) => void;\n}\n\nexport type getCurrentInstancePermissionSetErrors = GenericErrors;\n\nexport default new (class InstancePermissionSetClient extends ApiClient<IEvents> {\n    private _cachedInstancePermissionSet: Map<\n        number,\n        InternalStatus<Components.Schemas.InstancePermissionSetResponse, ErrorCode.OK>\n    > = new Map<\n        number,\n        InternalStatus<Components.Schemas.InstancePermissionSetResponse, ErrorCode.OK>\n    >();\n\n    private loadingInstancePermissionSetInfo: Map<number, boolean> = new Map<number, boolean>();\n\n    public constructor() {\n        super();\n\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedInstancePermissionSet.clear();\n        });\n    }\n\n    public async getCurrentInstancePermissionSet(\n        instanceid: number\n    ): Promise<\n        InternalStatus<\n            Components.Schemas.InstancePermissionSetResponse,\n            getCurrentInstancePermissionSetErrors\n        >\n    > {\n        await ServerClient.wait4Init();\n\n        if (this._cachedInstancePermissionSet.has(instanceid)) {\n            return this._cachedInstancePermissionSet.get(instanceid)!;\n        }\n\n        if (this.loadingInstancePermissionSetInfo.get(instanceid)) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<\n                        Components.Schemas.InstancePermissionSetResponse,\n                        GenericErrors\n                    >\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadInstancePermissionSet\", resolver);\n                };\n                this.on(\"loadInstancePermissionSet\", resolver);\n            });\n        }\n\n        this.loadingInstancePermissionSetInfo.set(instanceid, true);\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.InstancePermissionSetController_Read({\n                Instance: instanceid\n            });\n        } catch (stat) {\n            const res = new InternalStatus<\n                Components.Schemas.InstancePermissionSetResponse,\n                GenericErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadInstancePermissionSet\", res);\n            this.loadingInstancePermissionSetInfo.set(instanceid, false);\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<\n                    Components.Schemas.InstancePermissionSetResponse,\n                    ErrorCode.OK\n                >({\n                    code: StatusCode.OK,\n                    payload: response.data as Components.Schemas.InstancePermissionSetResponse\n                });\n\n                this._cachedInstancePermissionSet.set(instanceid, res);\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<\n                    Components.Schemas.InstancePermissionSetResponse,\n                    GenericErrors\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n        }\n    }\n})();\n","import { AxiosError, AxiosResponse, OpenAPIClientAxios } from \"openapi-client-axios\";\nimport { Document } from \"openapi-client-axios/types/client\";\n\nimport { API_VERSION, VERSION } from \"../definitions/constants\";\nimport { ApiClient } from \"./_base\";\nimport { Client, Components } from \"./generatedcode/_generated\";\nimport { CredentialsType, ICredentials } from \"./models/ICredentials\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport configOptions from \"./util/config\";\nimport CredentialsProvider from \"./util/CredentialsProvider\";\nimport LoginHooks from \"./util/LoginHooks\";\n\ninterface IEvents {\n    //self explainatory\n    logout: () => void;\n    //fired whenever something is denied access, shouldnt really be used\n    accessDenied: () => void;\n    //fired when the server info is first loaded\n    loadServerInfo: (\n        serverInfo: InternalStatus<Components.Schemas.ServerInformationResponse, ServerInfoErrors>\n    ) => void;\n    //fired when the api is loaded from the json file and loaded\n    initialized: () => void;\n    //purge all caches\n    purgeCache: () => void;\n    //internal event, queues logins\n    loadLoginInfo: (\n        loginInfo: InternalStatus<Components.Schemas.TokenResponse, LoginErrors>\n    ) => void;\n    //internal event fired for wait4Token(), external things should be using LoginHooks#LoginSuccess or a login hook\n    tokenAvailable: (token: Components.Schemas.TokenResponse) => void;\n}\n\nexport type LoginErrors =\n    | GenericErrors\n    | ErrorCode.LOGIN_DISABLED\n    | ErrorCode.LOGIN_FAIL\n    | ErrorCode.LOGIN_NOCREDS\n    | ErrorCode.LOGIN_BAD_OAUTH\n    | ErrorCode.LOGIN_RATELIMIT;\n\nexport type ServerInfoErrors = GenericErrors;\n\nexport default new (class ServerClient extends ApiClient<IEvents> {\n    private static readonly globalHandledCodes = [400, 401, 403, 406, 409, 426, 500, 501, 503];\n\n    //api\n    public apiClient?: Client; //client to interface with the api\n    private api?: OpenAPIClientAxios; //api object, handles sending requests and configuring things\n    private initialized = false;\n    private loadingServerInfo = false;\n\n    public constructor() {\n        super();\n        this.getServerInfo = this.getServerInfo.bind(this);\n\n        LoginHooks.addHook(this.getServerInfo);\n        this.on(\"purgeCache\", () => {\n            this._serverInfo = undefined;\n            if (CredentialsProvider.token) {\n                void LoginHooks.runHooks(CredentialsProvider.token);\n            }\n        });\n\n        //Why is this here? Because otherwise it creates an import loop, grrrrr\n        configOptions.apipath.callback = (): void => {\n            console.log(\"Reinitializing API\");\n            this.initApi()\n                .then(() => {\n                    console.log(\"API Reinitialized\");\n                })\n                .catch(() => {\n                    //The API failing to initialize is a big nono, start all over again.\n                    window.location.reload();\n                });\n        };\n    }\n\n    //serverInfo\n    private _serverInfo?: InternalStatus<\n        Components.Schemas.ServerInformationResponse,\n        ErrorCode.OK\n    >;\n\n    public get serverInfo() {\n        return this._serverInfo;\n    }\n\n    public autoLogin = true;\n    private loggingIn = false;\n\n    public async initApi() {\n        console.log(\"Initializing API client\");\n        console.time(\"APIInit\");\n        //Object is forced typecasted to Document because i really cant be assed to figure out why it doesn't accept the json\n        //The json is loaded with import to force webpack to bundle it alone\n        const defObj = ((await import(\"./generatedcode/swagger.json\"))\n            .default as unknown) as Document;\n\n        this.api = new OpenAPIClientAxios({\n            definition: defObj,\n            //Defaults for all requests sent by the apiClient, you may notice a lack of authorization headers,\n            // those are applied in the request interceptor\n            axiosConfigDefaults: {\n                //Yes this is only initialized once even if the configOption changes, this doesn't\n                baseURL: configOptions.apipath.value as string,\n                withCredentials: false,\n                headers: {\n                    Accept: \"application/json\",\n                    Api: `Tgstation.Server.Api/` + API_VERSION,\n                    \"Webpanel-Version\": VERSION\n                },\n                //Global errors are handled via the catch clause and endpoint specific response codes are handled normally\n                validateStatus: status => {\n                    return !ServerClient.globalHandledCodes.includes(status);\n                }\n            }\n        });\n        this.apiClient = await this.api.init<Client>();\n\n        //Oh lord here be shitcode, welcome to the land of interceptors, they as their name say\n        // intercept requests and changes them. It also intercepts responses and changes them\n        this.apiClient.interceptors.request.use(\n            async value => {\n                //Meta value that means theres no value, used in the github deployed version\n                if (configOptions.apipath.value === \"https://example.org:5000\") {\n                    const errorobj = new InternalError(ErrorCode.NO_APIPATH, {\n                        void: true\n                    });\n                    return Promise.reject(errorobj);\n                }\n\n                //This applies the authorization header, it will wait however long it needs until\n                // theres a token available. It obviously won't wait for a token before sending the request\n                // if its currently sending a request to the login endpoint...\n                if (!(value.url === \"/\" || value.url === \"\")) {\n                    const tok = await this.wait4Token();\n                    (value.headers as { [key: string]: string })[\"Authorization\"] =\n                        \"Bearer \" + tok.bearer;\n                }\n                return value;\n            },\n            error => {\n                return Promise.reject(error);\n            }\n        );\n\n        //I am sorry for what you will see before you, this is the response interceptor, it normalizes\n        // all the weird shit in the TGS api to make it *somewhat* easier to consume in the rest of the app\n        // onFulfilled here is a noop that returns its arguments because we only care to intercept errors\n        this.apiClient.interceptors.response.use(\n            val => val,\n            (error: AxiosError): Promise<AxiosResponse> => {\n                //THIS IS SNOWFLAKE KEKW\n                //As the above comment mentions, this shitcode is very snowflake\n                // it tries to typecast the \"response\" we got into an error then tries to check if that \"error\" is\n                // the snowflake no apipath github error, if it is, it rejects the promise to send it to the catch block\n                // all endpoints have which simply returns the error wrapped in a status object\n                const snowflake = (error as unknown) as InternalError<ErrorCode.NO_APIPATH>;\n                if (snowflake?.code === ErrorCode.NO_APIPATH) {\n                    return Promise.reject(snowflake);\n                }\n\n                //This was originally an else clause at the bottom but it made it hard to find\n                // if the promise rejected and its not because its a globally handled status code\n                // it means that axios created an error itself for an unknown reason(network failure,\n                // cors failure, user is navigating away, aborting requests, etc). Simply return the error\n                // as a globally handled error.\n                if (\n                    !(\n                        error.response &&\n                        error.response.status &&\n                        ServerClient.globalHandledCodes.includes(error.response.status)\n                    )\n                ) {\n                    const err = error as Error;\n                    const errorobj = new InternalError(\n                        ErrorCode.AXIOS,\n                        { jsError: err },\n                        error.response\n                    );\n                    return Promise.reject(errorobj);\n                }\n\n                //I am sorry, this is the bulk of the shitcode, its a massive switch that handles every single\n                // globally handled status code and sometimes not so globally because one endpoint decided it would be\n                const res = error.response as AxiosResponse<unknown>;\n                switch (error.response.status) {\n                    //Error code 400: Bad request, show message to user and instruct them to report it as its probably a bug\n                    case 400: {\n                        const errorMessage = res.data as Components.Schemas.ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_BAD_REQUEST,\n                            {\n                                errorMessage\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    //Error code 401: Access Denied, fired whenever a token expires, in that case, attempt to reauthenticate\n                    // using the last known working credentials, if that succeeds, reissue the request, otherwise logout the\n                    // user and kick them to the login page. Snowflake behaviour: Acts as a failed login for the login endpoint\n                    case 401: {\n                        const request = error.config;\n                        if (\n                            (request.url === \"/\" || request.url === \"\") &&\n                            request.method === \"post\"\n                        ) {\n                            return Promise.resolve(error.response);\n                        }\n\n                        if (this.autoLogin) {\n                            return this.login().then(status => {\n                                switch (status.code) {\n                                    case StatusCode.OK: {\n                                        return this.api!.client.request(error.config);\n                                    }\n                                    case StatusCode.ERROR: {\n                                        this.emit(\"accessDenied\");\n                                        //time to kick out the user\n                                        this.logout();\n                                        const errorobj = new InternalError(\n                                            ErrorCode.HTTP_ACCESS_DENIED,\n                                            {\n                                                void: true\n                                            },\n                                            res\n                                        );\n                                        return Promise.reject(errorobj);\n                                    }\n                                }\n                            });\n                        } else {\n                            this.emit(\"accessDenied\");\n                            const errorobj = new InternalError(\n                                ErrorCode.HTTP_ACCESS_DENIED,\n                                {\n                                    void: true\n                                },\n                                res\n                            );\n                            return Promise.reject(errorobj);\n                        }\n                    }\n                    case 403: {\n                        const request = error.config;\n                        if (\n                            (request.url === \"/\" || request.url === \"\") &&\n                            request.method === \"post\"\n                        ) {\n                            return Promise.resolve(error.response);\n                        } else {\n                            this.emit(\"accessDenied\");\n                            const errorobj = new InternalError(\n                                ErrorCode.HTTP_ACCESS_DENIED,\n                                {\n                                    void: true\n                                },\n                                res\n                            );\n                            return Promise.reject(errorobj);\n                        }\n                    }\n                    case 406: {\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_NOT_ACCEPTABLE,\n                            {\n                                void: true\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 409: {\n                        const errorMessage = res.data as Components.Schemas.ErrorMessageResponse;\n\n                        //Thanks for reusing a global erorr status cyber. Log operations can return 409\n                        const request = error.config;\n                        if (request.url === \"/Administration/Logs\" && request.method === \"get\") {\n                            return Promise.resolve(error.response);\n                        }\n\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_DATA_INEGRITY,\n                            {\n                                errorMessage\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 426: {\n                        const errorMessage = res.data as Components.Schemas.ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_API_MISMATCH,\n                            { errorMessage },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 500: {\n                        const errorMessage = res.data as Components.Schemas.ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_SERVER_ERROR,\n                            {\n                                errorMessage\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 501: {\n                        const errorMessage = res.data as Components.Schemas.ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_UNIMPLEMENTED,\n                            { errorMessage },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 503: {\n                        console.log(\"Server not ready, delaying request\", error.config);\n                        return new Promise(resolve => {\n                            setTimeout(resolve, 5000);\n                        }).then(() => this.api!.client.request(error.config));\n                        /*const errorobj = new InternalError(\n                                ErrorCode.HTTP_SERVER_NOT_READY,\n                                {\n                                    void: true\n                                },\n                                res\n                            );\n                            return Promise.reject(errorobj);*/\n                    }\n                    default: {\n                        const errorobj = new InternalError(\n                            ErrorCode.UNHANDLED_GLOBAL_RESPONSE,\n                            {\n                                axiosResponse: res\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                }\n            }\n        );\n        console.timeEnd(\"APIInit\");\n        this.initialized = true;\n        this.emit(\"initialized\");\n    }\n\n    //Utility function that returns a promise which resolves whenever ServerClient#ApiClient becomes valid\n    public wait4Init(): Promise<void> {\n        return new Promise<void>(resolve => {\n            if (this.initialized) {\n                resolve();\n                return;\n            }\n            this.on(\"initialized\", () => resolve());\n        });\n    }\n\n    //Utility function that returns a promise which resolves with the token whenever theres valid credentials(could be immediatly)\n    public wait4Token() {\n        return new Promise<Components.Schemas.TokenResponse>(resolve => {\n            if (CredentialsProvider.isTokenValid()) {\n                resolve(CredentialsProvider.token);\n                return;\n            }\n            this.on(\"tokenAvailable\", token => {\n                resolve(token);\n            });\n        });\n    }\n\n    public async login(\n        newCreds?: ICredentials\n    ): Promise<InternalStatus<Components.Schemas.TokenResponse, LoginErrors>> {\n        //Shouldn't really happen edge cases\n        await this.wait4Init();\n\n        console.log(\"Attempting login\");\n\n        //Newcreds is optional, if its missing its going to try to reuse the last used credentials,\n        // if newCreds exists, its going to use newCreds\n        let oauthAutoLogin = false;\n        if (newCreds) {\n            CredentialsProvider.credentials = newCreds;\n        } else if (CredentialsProvider.credentials?.type === CredentialsType.OAuth) {\n            // autologin doesn't work with OAuth\n            this.logout();\n            oauthAutoLogin = true;\n        }\n\n        //This is thrown if you try to reuse the last credentials without actually having last used credentials\n        //or you let an oauth login expire\n        if (oauthAutoLogin || !CredentialsProvider.credentials)\n            return new InternalStatus<Components.Schemas.TokenResponse, ErrorCode.LOGIN_NOCREDS>({\n                code: StatusCode.ERROR,\n                error: new InternalError(ErrorCode.LOGIN_NOCREDS, { void: true })\n            });\n\n        //This block is here to prevent duplication of login requests at the same time, when you start logging in,\n        // it sets loggingIn to true and fires an event once its done logging in, successful or not, if you try to login\n        // while another login request is ongoing, it listens to that event and returns the output normally.\n        //\n        // Basically, make two calls, receive two identical return values, make only one request\n        if (this.loggingIn) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    info: InternalStatus<Components.Schemas.TokenResponse, LoginErrors>\n                ) => {\n                    resolve(info);\n                    this.removeListener(\"loadLoginInfo\", resolver);\n                };\n                this.on(\"loadLoginInfo\", resolver);\n            });\n        }\n        this.loggingIn = true;\n\n        let response;\n        try {\n            if (CredentialsProvider.credentials.type == CredentialsType.Password)\n                response = await this.apiClient!.HomeController_CreateToken(\n                    {\n                        OAuthProvider: (undefined as unknown) as string\n                    },\n                    null,\n                    {\n                        auth: {\n                            username: CredentialsProvider.credentials.userName,\n                            password: CredentialsProvider.credentials.password\n                        }\n                    }\n                );\n            else {\n                response = await this.apiClient!.HomeController_CreateToken(\n                    {\n                        OAuthProvider: CredentialsProvider.credentials.provider\n                    },\n                    null,\n                    {\n                        headers: {\n                            Authorization: `OAuth ${CredentialsProvider.credentials.token}`\n                        }\n                    }\n                );\n            }\n        } catch (stat) {\n            const res = new InternalStatus<Components.Schemas.TokenResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadLoginInfo\", res);\n            return res;\n        } finally {\n            this.loggingIn = false;\n        }\n        switch (response.status) {\n            case 200: {\n                console.log(\"Login success\");\n                const token = response.data as Components.Schemas.TokenResponse;\n\n                // CredentialsProvider.token is added to all requests in the form of Authorization: Bearer <token>\n                CredentialsProvider.token = token;\n                this.emit(\"tokenAvailable\", token);\n\n                //LoginHooks are a way of running several async tasks at the same time whenever the user is authenticated,\n                // we cannot use events here as events wait on each listener before proceeding which has a noticable performance\n                // cost when it comes to several different requests to TGS,\n                // we cant directly call what we need to run here as it would violate isolation of\n                // ApiClient(the apiclient is independent from the rest of the app to avoid circular dependency\n                // (example: Component requires ServerClient to login and but the ServerClient requires Component to\n                // update it once the server info is loaded))\n                //\n                // TL;DR; Runs shit when you login\n\n                LoginHooks.runHooks(token);\n                const res = new InternalStatus<Components.Schemas.TokenResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: token\n                });\n                //Deduplication\n                this.emit(\"loadLoginInfo\", res);\n\n                return res;\n            }\n            case 401: {\n                this.logout();\n                console.log(\"Failed to login\");\n                const res = new InternalStatus<\n                    Components.Schemas.TokenResponse,\n                    ErrorCode.LOGIN_FAIL\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_FAIL,\n                        {\n                            void: true\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            case 403: {\n                this.logout();\n                console.log(\"Account disabled\");\n                const res = new InternalStatus<\n                    Components.Schemas.TokenResponse,\n                    ErrorCode.LOGIN_DISABLED\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_DISABLED,\n                        {\n                            void: true\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            case 429: {\n                this.logout();\n                console.log(\"rate limited\");\n                const res = new InternalStatus<\n                    Components.Schemas.TokenResponse,\n                    ErrorCode.LOGIN_RATELIMIT\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_RATELIMIT,\n                        {\n                            errorMessage: response.data as Components.Schemas.ErrorMessageResponse\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<\n                    Components.Schemas.TokenResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n        }\n    }\n\n    public logout() {\n        //If theres no token it means theres nothing to clear\n        if (!CredentialsProvider.isTokenValid()) {\n            return;\n        }\n        console.log(\"Logging out\");\n        CredentialsProvider.credentials = undefined;\n        CredentialsProvider.token = undefined;\n        //events to clear the app state as much as possible for the next user\n        this.emit(\"purgeCache\");\n        this.emit(\"logout\");\n    }\n\n    public async getServerInfo(\n        _token?: Components.Schemas.TokenResponse,\n        bypassCache = false\n    ): Promise<InternalStatus<Components.Schemas.ServerInformationResponse, ServerInfoErrors>> {\n        await this.wait4Init();\n\n        if (this._serverInfo && !bypassCache) {\n            return this._serverInfo;\n        }\n\n        if (this.loadingServerInfo) {\n            return new Promise(resolve => {\n                if (this._serverInfo) {\n                    //race condition if 2 things listen to an event or something\n                    resolve(this._serverInfo);\n                    return;\n                }\n                const resolver = (\n                    info: InternalStatus<\n                        Components.Schemas.ServerInformationResponse,\n                        GenericErrors\n                    >\n                ) => {\n                    resolve(info);\n                    this.removeListener(\"loadServerInfo\", resolver);\n                };\n                this.on(\"loadServerInfo\", resolver);\n            });\n        }\n\n        this.loadingServerInfo = true;\n\n        let response;\n        try {\n            response = await this.apiClient!.HomeController_Home();\n        } catch (stat) {\n            const res = new InternalStatus<\n                Components.Schemas.ServerInformationResponse,\n                GenericErrors\n            >({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadServerInfo\", res);\n            this.loadingServerInfo = false;\n            return res;\n        }\n        switch (response.status) {\n            case 200: {\n                const info = response.data as Components.Schemas.ServerInformationResponse;\n                const cache = new InternalStatus<\n                    Components.Schemas.ServerInformationResponse,\n                    ErrorCode.OK\n                >({\n                    code: StatusCode.OK,\n                    payload: info\n                });\n                this.emit(\"loadServerInfo\", cache);\n                this._serverInfo = cache;\n                this.loadingServerInfo = false;\n                return cache;\n            }\n            default: {\n                const res = new InternalStatus<\n                    Components.Schemas.ServerInformationResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadServerInfo\", res);\n                this.loadingServerInfo = false;\n                return res;\n            }\n        }\n    }\n})();\n\n//https://stackoverflow.com/questions/40510611/typescript-interface-require-one-of-two-properties-to-exist\n//name describes what it does, makes the passed type only require 1 property, the others being optional\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n    {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n    }[Keys];\n"],"sourceRoot":""}