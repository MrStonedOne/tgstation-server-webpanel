{"version":3,"sources":["webpack:///./src/ApiClient/TransferClient.ts"],"names":["ticket","response","ServerClient","wait4Init","apiClient","TransferController_Download","headers","Accept","stat","InternalStatus","code","StatusCode","ERROR","error","status","OK","payload","data","InternalError","ErrorCode","TRANSFER_NOT_AVAILABLE","errorMessage","UNHANDLED_RESPONSE","axiosResponse","file","TransferController_Upload","e","UPLOAD_FAILED","void","ApiClient"],"mappings":"8tDAYe,qB,kOAAA,U,MAAA,wE,EAAA,G,EAAA,uCACWA,GAGlB,IAAIC,QAFEC,IAAaC,YAGnB,IACIF,QAAiBC,IAAaE,UAAWC,4BACrC,CACIL,OAAQA,GAEZ,KACA,CACIM,QAAS,CACLC,OAAQ,gDAItB,MAAOC,GACL,OAAO,IAAIC,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAOL,IAIf,OAAQP,EAASa,QACb,KAAK,IACD,OAAO,IAAIL,IAAe,CACtBC,KAAMC,IAAWI,GACjBC,QAAUf,EAASgB,OAG3B,KAAK,IACD,OAAO,IAAIR,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAO,IAAIK,IAAcC,IAAUC,uBAAwB,CACvDC,aAAcpB,EAASgB,SAInC,QACI,OAAO,IAAIR,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAO,IAAIK,IACPC,IAAUG,mBACV,CAAEC,cAAetB,GACjBA,SA7CT,kFAqDPD,EACAwB,GAIA,IAAIvB,QAFEC,IAAaC,YAGnB,IACIF,QAAiBC,IAAaE,UAAWqB,0BACrC,CAAEzB,OAAQA,GACV,KACA,CACIiB,KAAMO,EACNlB,QAAS,CACL,eAAgB,+BAI9B,MAAOoB,GACL,OAAO,IAAIjB,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAOa,IAIf,OAAQzB,EAASa,QACb,KAAK,IACD,OAAO,IAAIL,IAAe,CACtBC,KAAMC,IAAWI,GACjBC,QAAS,OAGjB,KAAK,IACD,OAAO,IAAIP,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAO,IAAIK,IAAcC,IAAUQ,cAAe,CAC9CC,MAAM,MAIlB,KAAK,IACD,OAAO,IAAInB,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAO,IAAIK,IAAcC,IAAUC,uBAAwB,CACvDC,aAAcpB,EAASgB,SAInC,QACI,OAAO,IAAIR,IAAe,CACtBC,KAAMC,IAAWC,MACjBC,MAAO,IAAIK,IACPC,IAAUG,mBACV,CAAEC,cAAetB,GACjBA,SA1GT,mD,2BAAA,GAAkC4B","file":"2.b79a89787fdbb0a5972b.js","sourcesContent":["import { ApiClient } from \"./_base\";\nimport { Components } from \"./generatedcode/_generated\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\nexport type DownloadErrors = GenericErrors | ErrorCode.TRANSFER_NOT_AVAILABLE;\nexport type UploadErrors =\n    | GenericErrors\n    | ErrorCode.TRANSFER_NOT_AVAILABLE\n    | ErrorCode.UPLOAD_FAILED;\n\nexport default new (class TransferClient extends ApiClient {\n    public async Download(ticket: string): Promise<InternalStatus<string, DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.TransferController_Download(\n                {\n                    ticket: ticket\n                },\n                null,\n                {\n                    headers: {\n                        Accept: \"application/json, application/octet-stream\"\n                    }\n                }\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: (response.data as unknown) as string\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.TRANSFER_NOT_AVAILABLE, {\n                        errorMessage: response.data as Components.Schemas.ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async Upload(\n        ticket: string,\n        file: ArrayBuffer\n    ): Promise<InternalStatus<null, UploadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.TransferController_Upload(\n                { ticket: ticket },\n                null,\n                {\n                    data: file,\n                    headers: {\n                        \"Content-Type\": \"application/octect-stream\"\n                    }\n                }\n            );\n        } catch (e) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: e as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: null\n                });\n            }\n            case 409: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.UPLOAD_FAILED, {\n                        void: true\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.TRANSFER_NOT_AVAILABLE, {\n                        errorMessage: response.data as Components.Schemas.ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n"],"sourceRoot":""}