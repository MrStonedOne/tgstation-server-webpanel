{"version":3,"sources":["webpack://tgstation-server-control-panel/./src/ApiClient/AdminClient.ts"],"names":["_cachedAdminInfo","loadingAdminInfo","ServerClient","undefined","this","response","Promise","resolve","on","resolver","user","removeListener","stat","res","InternalStatus","code","StatusCode","error","emit","status","thing","payload","data","errorMessage","InternalError","ErrorCode","axiosResponse","newVersion","pageSize","page","content","logName","path","contents","TransferClient","fileTicket","temp","Object","assign","ApiClient"],"mappings":"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","file":"820.3c21f444f2bbc81490ab.js","sourcesContent":["import { ApiClient } from \"./_base\";\nimport {\n    AdministrationResponse,\n    ErrorMessageResponse,\n    LogFileResponse,\n    PaginatedLogFileResponse\n} from \"./generatedcode/schemas\";\nimport { DownloadedLog } from \"./models/DownloadedLog\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport TransferClient, { DownloadErrors } from \"./TransferClient\";\n\ninterface IEvents {\n    loadAdminInfo: (user: InternalStatus<AdministrationResponse, AdminInfoErrors>) => void;\n}\n\nexport type AdminInfoErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type RestartErrors = GenericErrors | ErrorCode.ADMIN_WATCHDOG_UNAVAIL;\n\nexport type UpdateErrors =\n    | GenericErrors\n    | ErrorCode.ADMIN_WATCHDOG_UNAVAIL\n    | ErrorCode.ADMIN_VERSION_NOT_FOUND\n    | ErrorCode.ADMIN_GITHUB_RATE\n    | ErrorCode.ADMIN_GITHUB_ERROR;\n\nexport type LogsErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport type LogErrors = GenericErrors | ErrorCode.ADMIN_LOGS_IO_ERROR;\n\nexport default new (class AdminClient extends ApiClient<IEvents> {\n    private _cachedAdminInfo?: InternalStatus<AdministrationResponse, ErrorCode.OK>;\n    public get cachedAdminInfo() {\n        return this._cachedAdminInfo;\n    }\n    private loadingAdminInfo = false;\n\n    public constructor() {\n        super();\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedAdminInfo = undefined;\n        });\n    }\n\n    public async getAdminInfo(): Promise<InternalStatus<AdministrationResponse, AdminInfoErrors>> {\n        await ServerClient.wait4Init();\n        if (this._cachedAdminInfo) {\n            return this._cachedAdminInfo;\n        }\n\n        if (this.loadingAdminInfo) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<AdministrationResponse, AdminInfoErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadAdminInfo\", resolver);\n                };\n                this.on(\"loadAdminInfo\", resolver);\n            });\n        }\n\n        this.loadingAdminInfo = true;\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Read();\n        } catch (stat) {\n            const res = new InternalStatus<AdministrationResponse, AdminInfoErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<AdminInfoErrors>\n            });\n            this.emit(\"loadAdminInfo\", res);\n            this.loadingAdminInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<AdministrationResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as AdministrationResponse\n                });\n\n                this._cachedAdminInfo = thing;\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 424: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                const thing = new InternalStatus<\n                    AdministrationResponse,\n                    ErrorCode.ADMIN_GITHUB_RATE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            case 429: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                const thing = new InternalStatus<\n                    AdministrationResponse,\n                    ErrorCode.ADMIN_GITHUB_ERROR\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", thing);\n                this.loadingAdminInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<\n                    AdministrationResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadAdminInfo\", res);\n                this.loadingAdminInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async restartServer(): Promise<InternalStatus<null, RestartErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Delete();\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<RestartErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 204: {\n                return new InternalStatus({ code: StatusCode.OK, payload: null });\n            }\n            case 422: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async updateServer(newVersion: string): Promise<InternalStatus<null, UpdateErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_Update(null, {\n                newVersion\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<UpdateErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                return new InternalStatus({ code: StatusCode.OK, payload: null });\n            }\n            case 410: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_VERSION_NOT_FOUND,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 422: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_WATCHDOG_UNAVAIL,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 424: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus<null, ErrorCode.ADMIN_GITHUB_RATE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_RATE,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            case 429: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus<null, ErrorCode.ADMIN_GITHUB_ERROR>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_GITHUB_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus<null, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLogs(): Promise<InternalStatus<LogFileResponse[], LogsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_ListLogs({\n                pageSize: 100,\n                page: 1\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<LogsErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: (response.data as PaginatedLogFileResponse)!.content\n                });\n            }\n            case 409: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getLog(\n        logName: string\n    ): Promise<InternalStatus<DownloadedLog, LogErrors | DownloadErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.AdministrationController_GetLog({\n                path: logName\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                const contents = await TransferClient.Download(\n                    (response.data as LogFileResponse).fileTicket\n                );\n                if (contents.code === StatusCode.OK) {\n                    //Object.assign() is a funky function but all it does is copy everything from the second object to the first object\n                    const temp: DownloadedLog = Object.assign(\n                        { content: contents.payload },\n                        response.data as LogFileResponse\n                    );\n                    return new InternalStatus({\n                        code: StatusCode.OK,\n                        payload: temp\n                    });\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: contents.error\n                    });\n                }\n            }\n            case 409: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.ADMIN_LOGS_IO_ERROR,\n                        { errorMessage },\n                        response\n                    )\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n"],"sourceRoot":""}