{"version":3,"file":"189.51b47d326431c7125319.js","mappings":"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","sources":["webpack://tgstation-server-control-panel/./src/ApiClient/InstanceClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/InstancePermissionSetClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/JobsClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/ServerClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/UserClient.ts","webpack://tgstation-server-control-panel/./src/ApiClient/_base.ts","webpack://tgstation-server-control-panel/./src/ApiClient/generatedcode/_enums.ts","webpack://tgstation-server-control-panel/./src/ApiClient/models/ICredentials.ts","webpack://tgstation-server-control-panel/./src/ApiClient/models/InternalComms/InternalError.ts","webpack://tgstation-server-control-panel/./src/ApiClient/models/InternalComms/InternalStatus.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/ConfigController.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/CredentialsProvider.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/JobsController.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/LoginHooks.ts","webpack://tgstation-server-control-panel/./src/ApiClient/util/config.ts"],"sourcesContent":["import { ApiClient } from \"./_base\";\nimport {\n    ErrorMessageResponse,\n    InstanceCreateRequest,\n    InstanceResponse,\n    InstanceUpdateRequest,\n    PaginatedInstanceResponse\n} from \"./generatedcode/schemas\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type ListInstancesErrors = GenericErrors;\nexport type CreateInstanceErrors = GenericErrors;\nexport type EditInstanceErrors = GenericErrors | ErrorCode.INSTANCE_NO_DB_ENTITY;\nexport type GetInstanceErrors = GenericErrors | ErrorCode.INSTANCE_NO_DB_ENTITY;\n\ninterface IEvents {\n    instanceChange: (instanceId: number) => void;\n}\n\nexport default new (class InstanceClient extends ApiClient<IEvents> {\n    public async listInstances({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    } = {}): Promise<InternalStatus<PaginatedInstanceResponse, ListInstancesErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.InstanceController_List({\n                pageSize: pageSize,\n                page: page\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as PaginatedInstanceResponse\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async editInstance(\n        instance: InstanceUpdateRequest\n    ): Promise<InternalStatus<InstanceResponse, EditInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.InstanceController_Update(null, instance);\n            this.emit(\"instanceChange\", instance.id);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 202: {\n                const instance = response.data as InstanceResponse;\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: instance\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.INSTANCE_NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createInstance(\n        instance: InstanceCreateRequest\n    ): Promise<InternalStatus<InstanceResponse, CreateInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.InstanceController_Create(null, instance);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200:\n            case 201: {\n                const instance = response.data as InstanceResponse;\n\n                this.emit(\"instanceChange\", instance.id);\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: instance\n                });\n            }\n            case 409:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.HTTP_DATA_INEGRITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getInstance(\n        instanceid: number\n    ): Promise<InternalStatus<InstanceResponse, GetInstanceErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.InstanceController_GetId({ id: instanceid });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as InstanceResponse\n                });\n            }\n            case 410:\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.INSTANCE_NO_DB_ENTITY, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport { InstancePermissionSetResponse } from \"./generatedcode/schemas\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\n\ninterface IEvents {\n    loadInstancePermissionSet: (\n        user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n    ) => void;\n}\n\nexport type getCurrentInstancePermissionSetErrors = GenericErrors;\n\nexport default new (class InstancePermissionSetClient extends ApiClient<IEvents> {\n    private _cachedInstancePermissionSet: Map<\n        number,\n        InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>\n    > = new Map<number, InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>>();\n\n    private loadingInstancePermissionSetInfo: Map<number, boolean> = new Map<number, boolean>();\n\n    public constructor() {\n        super();\n\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedInstancePermissionSet.clear();\n        });\n    }\n\n    public async getCurrentInstancePermissionSet(\n        instanceid: number\n    ): Promise<\n        InternalStatus<InstancePermissionSetResponse, getCurrentInstancePermissionSetErrors>\n    > {\n        await ServerClient.wait4Init();\n\n        if (this._cachedInstancePermissionSet.has(instanceid)) {\n            return this._cachedInstancePermissionSet.get(instanceid)!;\n        }\n\n        if (this.loadingInstancePermissionSetInfo.get(instanceid)) {\n            return await new Promise(resolve => {\n                const resolver = (\n                    user: InternalStatus<InstancePermissionSetResponse, GenericErrors>\n                ) => {\n                    resolve(user);\n                    this.removeListener(\"loadInstancePermissionSet\", resolver);\n                };\n                this.on(\"loadInstancePermissionSet\", resolver);\n            });\n        }\n\n        this.loadingInstancePermissionSetInfo.set(instanceid, true);\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.InstancePermissionSetController_Read({\n                Instance: instanceid\n            });\n        } catch (stat) {\n            const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadInstancePermissionSet\", res);\n            this.loadingInstancePermissionSetInfo.set(instanceid, false);\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const res = new InternalStatus<InstancePermissionSetResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as InstancePermissionSetResponse\n                });\n\n                this._cachedInstancePermissionSet.set(instanceid, res);\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<InstancePermissionSetResponse, GenericErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadInstancePermissionSet\", res);\n                this.loadingInstancePermissionSetInfo.set(instanceid, false);\n                return res;\n            }\n        }\n    }\n})();\n","import { ApiClient } from \"./_base\";\nimport { ErrorMessageResponse, JobResponse, PaginatedJobResponse } from \"./generatedcode/schemas\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\n\nexport type listJobsErrors = GenericErrors;\nexport type getJobErrors = GenericErrors | ErrorCode.JOB_JOB_NOT_FOUND;\nexport type deleteJobErrors =\n    | GenericErrors\n    | ErrorCode.JOB_JOB_NOT_FOUND\n    | ErrorCode.JOB_JOB_COMPLETE;\n\nexport type PaginatedTGSJobResponse = Omit<PaginatedJobResponse, \"content\"> & {\n    content: TGSJobResponse[];\n};\nexport type TGSJobResponse = JobResponse & {\n    instanceid: number;\n    canCancel?: boolean;\n};\n\nexport default new (class JobsClient extends ApiClient {\n    public async listActiveJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, listJobsErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_Read({\n                Instance: instanceid,\n                page: page,\n                pageSize: pageSize\n            });\n        } catch (stat) {\n            return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, getJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_GetId({\n                Instance: instanceid,\n                id: jobid\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async deleteJob(\n        instanceid: number,\n        jobid: number\n    ): Promise<InternalStatus<TGSJobResponse, deleteJobErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_Delete({\n                Instance: instanceid,\n                id: jobid\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 202: {\n                const job = {\n                    ...(response.data as JobResponse),\n                    instanceid: instanceid\n                };\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: job\n                });\n            }\n            case 404: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_NOT_FOUND, {\n                        errorMessage: response.data as ErrorMessageResponse\n                    })\n                });\n            }\n            case 410: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.JOB_JOB_COMPLETE, {\n                        void: true\n                    })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async listJobs(\n        instanceid: number,\n        { page = 1, pageSize = configOptions.itemsperpage.value as number }\n    ): Promise<InternalStatus<PaginatedTGSJobResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.JobController_List({\n                Instance: instanceid,\n                pageSize,\n                page\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const newContent = (response.data as PaginatedJobResponse).content.map(job => {\n                    return {\n                        ...job,\n                        instanceid: instanceid\n                    };\n                });\n\n                return new InternalStatus<PaginatedTGSJobResponse, listJobsErrors>({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedJobResponse),\n                        content: newContent\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { AxiosError, AxiosResponse, OpenAPIClientAxios } from \"openapi-client-axios\";\nimport { Document } from \"openapi-client-axios/types/client\";\n\nimport { API_VERSION, VERSION } from \"../definitions/constants\";\nimport { ApiClient } from \"./_base\";\nimport { Client } from \"./generatedcode/_generated\";\nimport {\n    ErrorMessageResponse,\n    ServerInformationResponse,\n    TokenResponse\n} from \"./generatedcode/schemas\";\nimport { CredentialsType, ICredentials } from \"./models/ICredentials\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport configOptions from \"./util/config\";\nimport CredentialsProvider from \"./util/CredentialsProvider\";\nimport LoginHooks from \"./util/LoginHooks\";\n\ninterface IEvents {\n    //self explainatory\n    logout: () => void;\n    //fired whenever something is denied access, shouldnt really be used\n    accessDenied: () => void;\n    //fired when the server info is first loaded\n    loadServerInfo: (\n        serverInfo: InternalStatus<ServerInformationResponse, ServerInfoErrors>\n    ) => void;\n    //fired when the api is loaded from the json file and loaded\n    initialized: () => void;\n    //purge all caches\n    purgeCache: () => void;\n    //internal event, queues logins\n    loadLoginInfo: (loginInfo: InternalStatus<TokenResponse, LoginErrors>) => void;\n    //internal event fired for wait4Token(), external things should be using LoginHooks#LoginSuccess or a login hook\n    tokenAvailable: (token: TokenResponse) => void;\n}\n\nexport type LoginErrors =\n    | GenericErrors\n    | ErrorCode.LOGIN_DISABLED\n    | ErrorCode.LOGIN_FAIL\n    | ErrorCode.LOGIN_NOCREDS\n    | ErrorCode.LOGIN_BAD_OAUTH\n    | ErrorCode.LOGIN_RATELIMIT;\n\nexport type ServerInfoErrors = GenericErrors;\n\nexport default new (class ServerClient extends ApiClient<IEvents> {\n    private static readonly globalHandledCodes = [400, 401, 403, 406, 409, 426, 500, 501, 503];\n\n    //api\n    public apiClient?: Client; //client to interface with the api\n    private api?: OpenAPIClientAxios; //api object, handles sending requests and configuring things\n    private initialized = false;\n    private loadingServerInfo = false;\n\n    public constructor() {\n        super();\n        this.getServerInfo = this.getServerInfo.bind(this);\n\n        LoginHooks.addHook(this.getServerInfo);\n        this.on(\"purgeCache\", () => {\n            this._serverInfo = undefined;\n            if (CredentialsProvider.token) {\n                void LoginHooks.runHooks(CredentialsProvider.token);\n            }\n        });\n\n        //Why is this here? Because otherwise it creates an import loop, grrrrr\n        configOptions.apipath.callback = (): void => {\n            console.log(\"Reinitializing API\");\n            this.initApi()\n                .then(() => {\n                    console.log(\"API Reinitialized\");\n                })\n                .catch(() => {\n                    //The API failing to initialize is a big nono, start all over again.\n                    window.location.reload();\n                });\n        };\n    }\n\n    //serverInfo\n    private _serverInfo?: InternalStatus<ServerInformationResponse, ErrorCode.OK>;\n\n    public get serverInfo() {\n        return this._serverInfo;\n    }\n\n    public autoLogin = true;\n    private loggingIn = false;\n\n    public async initApi() {\n        console.log(\"Initializing API client\");\n        console.time(\"APIInit\");\n        //Object is forced typecasted to Document because i really cant be assed to figure out why it doesn't accept the json\n        //The json is loaded with import to force webpack to bundle it alone\n        const defObj = (await import(\"./generatedcode/swagger.json\"))\n            .default as unknown as Document;\n\n        this.api = new OpenAPIClientAxios({\n            definition: defObj,\n            //Defaults for all requests sent by the apiClient, you may notice a lack of authorization headers,\n            // those are applied in the request interceptor\n            axiosConfigDefaults: {\n                //Yes this is only initialized once even if the configOption changes, this doesn't\n                baseURL: configOptions.apipath.value as string,\n                withCredentials: false,\n                headers: {\n                    Accept: \"application/json\",\n                    Api: `Tgstation.Server.Api/` + API_VERSION,\n                    \"Webpanel-Version\": VERSION\n                },\n                //Global errors are handled via the catch clause and endpoint specific response codes are handled normally\n                validateStatus: status => {\n                    return !ServerClient.globalHandledCodes.includes(status);\n                }\n            }\n        });\n        this.apiClient = await this.api.init<Client>();\n\n        //Oh lord here be shitcode, welcome to the land of interceptors, they as their name say\n        // intercept requests and changes them. It also intercepts responses and changes them\n        this.apiClient.interceptors.request.use(\n            async value => {\n                //Meta value that means theres no value, used in the github deployed version\n                if (configOptions.apipath.value === \"https://example.org:5000\") {\n                    const errorobj = new InternalError(ErrorCode.NO_APIPATH, {\n                        void: true\n                    });\n                    return Promise.reject(errorobj);\n                }\n\n                //This applies the authorization header, it will wait however long it needs until\n                // theres a token available. It obviously won't wait for a token before sending the request\n                // if its currently sending a request to the login endpoint...\n                if (!(value.url === \"/\" || value.url === \"\")) {\n                    const tok = await this.wait4Token();\n                    (value.headers as { [key: string]: string })[\"Authorization\"] =\n                        \"Bearer \" + tok.bearer;\n                }\n                return value;\n            },\n            error => {\n                return Promise.reject(error);\n            }\n        );\n\n        //I am sorry for what you will see before you, this is the response interceptor, it normalizes\n        // all the weird shit in the TGS api to make it *somewhat* easier to consume in the rest of the app\n        // onFulfilled here is a noop that returns its arguments because we only care to intercept errors\n        this.apiClient.interceptors.response.use(\n            val => val,\n            (error: AxiosError): Promise<AxiosResponse> => {\n                //THIS IS SNOWFLAKE KEKW\n                //As the above comment mentions, this shitcode is very snowflake\n                // it tries to typecast the \"response\" we got into an error then tries to check if that \"error\" is\n                // the snowflake no apipath github error, if it is, it rejects the promise to send it to the catch block\n                // all endpoints have which simply returns the error wrapped in a status object\n                const snowflake = error as unknown as InternalError<ErrorCode.NO_APIPATH>;\n                if (snowflake?.code === ErrorCode.NO_APIPATH) {\n                    return Promise.reject(snowflake);\n                }\n\n                //This was originally an else clause at the bottom but it made it hard to find\n                // if the promise rejected and its not because its a globally handled status code\n                // it means that axios created an error itself for an unknown reason(network failure,\n                // cors failure, user is navigating away, aborting requests, etc). Simply return the error\n                // as a globally handled error.\n                if (\n                    !(\n                        error.response &&\n                        error.response.status &&\n                        ServerClient.globalHandledCodes.includes(error.response.status)\n                    )\n                ) {\n                    const err = error as Error;\n                    const errorobj = new InternalError(\n                        ErrorCode.AXIOS,\n                        { jsError: err },\n                        error.response\n                    );\n                    return Promise.reject(errorobj);\n                }\n\n                //I am sorry, this is the bulk of the shitcode, its a massive switch that handles every single\n                // globally handled status code and sometimes not so globally because one endpoint decided it would be\n                const res = error.response as AxiosResponse<unknown>;\n                switch (error.response.status) {\n                    //Error code 400: Bad request, show message to user and instruct them to report it as its probably a bug\n                    case 400: {\n                        const errorMessage = res.data as ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_BAD_REQUEST,\n                            {\n                                errorMessage\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    //Error code 401: Access Denied, fired whenever a token expires, in that case, attempt to reauthenticate\n                    // using the last known working credentials, if that succeeds, reissue the request, otherwise logout the\n                    // user and kick them to the login page. Snowflake behaviour: Acts as a failed login for the login endpoint\n                    case 401: {\n                        const request = error.config;\n                        if (\n                            (request.url === \"/\" || request.url === \"\") &&\n                            request.method === \"post\"\n                        ) {\n                            return Promise.resolve(error.response);\n                        }\n\n                        if (this.autoLogin) {\n                            return this.login().then(status => {\n                                switch (status.code) {\n                                    case StatusCode.OK: {\n                                        return this.api!.client.request(error.config);\n                                    }\n                                    case StatusCode.ERROR: {\n                                        this.emit(\"accessDenied\");\n                                        //time to kick out the user\n                                        this.logout();\n                                        const errorobj = new InternalError(\n                                            ErrorCode.HTTP_ACCESS_DENIED,\n                                            {\n                                                void: true\n                                            },\n                                            res\n                                        );\n                                        return Promise.reject(errorobj);\n                                    }\n                                }\n                            });\n                        } else {\n                            this.emit(\"accessDenied\");\n                            const errorobj = new InternalError(\n                                ErrorCode.HTTP_ACCESS_DENIED,\n                                {\n                                    void: true\n                                },\n                                res\n                            );\n                            return Promise.reject(errorobj);\n                        }\n                    }\n                    case 403: {\n                        const request = error.config;\n                        if (\n                            (request.url === \"/\" || request.url === \"\") &&\n                            request.method === \"post\"\n                        ) {\n                            return Promise.resolve(error.response);\n                        } else {\n                            this.emit(\"accessDenied\");\n                            const errorobj = new InternalError(\n                                ErrorCode.HTTP_ACCESS_DENIED,\n                                {\n                                    void: true\n                                },\n                                res\n                            );\n                            return Promise.reject(errorobj);\n                        }\n                    }\n                    case 406: {\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_NOT_ACCEPTABLE,\n                            {\n                                void: true\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 409: {\n                        const errorMessage = res.data as ErrorMessageResponse;\n\n                        //Thanks for reusing a global erorr status cyber. Log operations can return 409\n                        const request = error.config;\n                        if (request.url === \"/Administration/Logs\" && request.method === \"get\") {\n                            return Promise.resolve(error.response);\n                        }\n\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_DATA_INEGRITY,\n                            {\n                                errorMessage\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 426: {\n                        const errorMessage = res.data as ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_API_MISMATCH,\n                            { errorMessage },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 500: {\n                        const errorMessage = res.data as ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_SERVER_ERROR,\n                            {\n                                errorMessage\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 501: {\n                        const errorMessage = res.data as ErrorMessageResponse;\n                        const errorobj = new InternalError(\n                            ErrorCode.HTTP_UNIMPLEMENTED,\n                            { errorMessage },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                    case 503: {\n                        console.log(\"Server not ready, delaying request\", error.config);\n                        return new Promise(resolve => {\n                            setTimeout(resolve, 5000);\n                        }).then(() => this.api!.client.request(error.config));\n                        /*const errorobj = new InternalError(\n                                ErrorCode.HTTP_SERVER_NOT_READY,\n                                {\n                                    void: true\n                                },\n                                res\n                            );\n                            return Promise.reject(errorobj);*/\n                    }\n                    default: {\n                        const errorobj = new InternalError(\n                            ErrorCode.UNHANDLED_GLOBAL_RESPONSE,\n                            {\n                                axiosResponse: res\n                            },\n                            res\n                        );\n                        return Promise.reject(errorobj);\n                    }\n                }\n            }\n        );\n        console.timeEnd(\"APIInit\");\n        this.initialized = true;\n        this.emit(\"initialized\");\n    }\n\n    //Utility function that returns a promise which resolves whenever ServerClient#ApiClient becomes valid\n    public wait4Init(): Promise<void> {\n        return new Promise<void>(resolve => {\n            if (this.initialized) {\n                resolve();\n                return;\n            }\n            this.on(\"initialized\", () => resolve());\n        });\n    }\n\n    //Utility function that returns a promise which resolves with the token whenever theres valid credentials(could be immediatly)\n    public wait4Token() {\n        return new Promise<TokenResponse>(resolve => {\n            if (CredentialsProvider.isTokenValid()) {\n                resolve(CredentialsProvider.token!);\n                return;\n            }\n            this.on(\"tokenAvailable\", token => {\n                resolve(token);\n            });\n        });\n    }\n\n    public async login(\n        newCreds?: ICredentials\n    ): Promise<InternalStatus<TokenResponse, LoginErrors>> {\n        //Shouldn't really happen edge cases\n        await this.wait4Init();\n\n        console.log(\"Attempting login\");\n\n        //Newcreds is optional, if its missing its going to try to reuse the last used credentials,\n        // if newCreds exists, its going to use newCreds\n        let oauthAutoLogin = false;\n        if (newCreds) {\n            CredentialsProvider.credentials = newCreds;\n        } else if (CredentialsProvider.credentials?.type === CredentialsType.OAuth) {\n            // autologin doesn't work with OAuth\n            this.logout();\n            oauthAutoLogin = true;\n        }\n\n        //This is thrown if you try to reuse the last credentials without actually having last used credentials\n        //or you let an oauth login expire\n        if (oauthAutoLogin || !CredentialsProvider.credentials)\n            return new InternalStatus<TokenResponse, ErrorCode.LOGIN_NOCREDS>({\n                code: StatusCode.ERROR,\n                error: new InternalError(ErrorCode.LOGIN_NOCREDS, { void: true })\n            });\n\n        //This block is here to prevent duplication of login requests at the same time, when you start logging in,\n        // it sets loggingIn to true and fires an event once its done logging in, successful or not, if you try to login\n        // while another login request is ongoing, it listens to that event and returns the output normally.\n        //\n        // Basically, make two calls, receive two identical return values, make only one request\n        if (this.loggingIn) {\n            return await new Promise(resolve => {\n                const resolver = (info: InternalStatus<TokenResponse, LoginErrors>) => {\n                    resolve(info);\n                    this.removeListener(\"loadLoginInfo\", resolver);\n                };\n                this.on(\"loadLoginInfo\", resolver);\n            });\n        }\n        this.loggingIn = true;\n\n        let response;\n        try {\n            if (CredentialsProvider.credentials.type == CredentialsType.Password)\n                response = await this.apiClient!.HomeController_CreateToken(\n                    {\n                        OAuthProvider: undefined as unknown as string\n                    },\n                    null,\n                    {\n                        auth: {\n                            username: CredentialsProvider.credentials.userName,\n                            password: CredentialsProvider.credentials.password\n                        }\n                    }\n                );\n            else {\n                response = await this.apiClient!.HomeController_CreateToken(\n                    {\n                        OAuthProvider: CredentialsProvider.credentials.provider\n                    },\n                    null,\n                    {\n                        headers: {\n                            Authorization: `OAuth ${CredentialsProvider.credentials.token}`\n                        }\n                    }\n                );\n            }\n        } catch (stat) {\n            const res = new InternalStatus<TokenResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadLoginInfo\", res);\n            return res;\n        } finally {\n            this.loggingIn = false;\n        }\n        switch (response.status) {\n            case 200: {\n                console.log(\"Login success\");\n                const token = response.data as TokenResponse;\n\n                // CredentialsProvider.token is added to all requests in the form of Authorization: Bearer <token>\n                CredentialsProvider.token = token;\n                this.emit(\"tokenAvailable\", token);\n\n                //LoginHooks are a way of running several async tasks at the same time whenever the user is authenticated,\n                // we cannot use events here as events wait on each listener before proceeding which has a noticable performance\n                // cost when it comes to several different requests to TGS,\n                // we cant directly call what we need to run here as it would violate isolation of\n                // ApiClient(the apiclient is independent from the rest of the app to avoid circular dependency\n                // (example: Component requires ServerClient to login and but the ServerClient requires Component to\n                // update it once the server info is loaded))\n                //\n                // TL;DR; Runs shit when you login\n\n                LoginHooks.runHooks(token);\n                const res = new InternalStatus<TokenResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: token\n                });\n                //Deduplication\n                this.emit(\"loadLoginInfo\", res);\n\n                return res;\n            }\n            case 401: {\n                this.logout();\n                console.log(\"Failed to login\");\n                const res = new InternalStatus<TokenResponse, ErrorCode.LOGIN_FAIL>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_FAIL,\n                        {\n                            void: true\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            case 403: {\n                this.logout();\n                console.log(\"Account disabled\");\n                const res = new InternalStatus<TokenResponse, ErrorCode.LOGIN_DISABLED>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_DISABLED,\n                        {\n                            void: true\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            case 429: {\n                this.logout();\n                console.log(\"rate limited\");\n                const res = new InternalStatus<TokenResponse, ErrorCode.LOGIN_RATELIMIT>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.LOGIN_RATELIMIT,\n                        {\n                            errorMessage: response.data as ErrorMessageResponse\n                        },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n            default: {\n                const res = new InternalStatus<TokenResponse, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadLoginInfo\", res);\n                return res;\n            }\n        }\n    }\n\n    public logout() {\n        //If theres no token it means theres nothing to clear\n        if (!CredentialsProvider.isTokenValid()) {\n            return;\n        }\n        console.log(\"Logging out\");\n        CredentialsProvider.credentials = undefined;\n        CredentialsProvider.token = undefined;\n        //events to clear the app state as much as possible for the next user\n        this.emit(\"purgeCache\");\n        this.emit(\"logout\");\n    }\n\n    public async getServerInfo(\n        _token?: TokenResponse,\n        bypassCache = false\n    ): Promise<InternalStatus<ServerInformationResponse, ServerInfoErrors>> {\n        await this.wait4Init();\n\n        if (this._serverInfo && !bypassCache) {\n            return this._serverInfo;\n        }\n\n        if (this.loadingServerInfo) {\n            return new Promise(resolve => {\n                if (this._serverInfo) {\n                    //race condition if 2 things listen to an event or something\n                    resolve(this._serverInfo);\n                    return;\n                }\n                const resolver = (\n                    info: InternalStatus<ServerInformationResponse, GenericErrors>\n                ) => {\n                    resolve(info);\n                    this.removeListener(\"loadServerInfo\", resolver);\n                };\n                this.on(\"loadServerInfo\", resolver);\n            });\n        }\n\n        this.loadingServerInfo = true;\n\n        let response;\n        try {\n            response = await this.apiClient!.HomeController_Home();\n        } catch (stat) {\n            const res = new InternalStatus<ServerInformationResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadServerInfo\", res);\n            this.loadingServerInfo = false;\n            return res;\n        }\n        switch (response.status) {\n            case 200: {\n                const info = response.data as ServerInformationResponse;\n                const cache = new InternalStatus<ServerInformationResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: info\n                });\n                this.emit(\"loadServerInfo\", cache);\n                this._serverInfo = cache;\n                this.loadingServerInfo = false;\n                return cache;\n            }\n            default: {\n                const res = new InternalStatus<\n                    ServerInformationResponse,\n                    ErrorCode.UNHANDLED_RESPONSE\n                >({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadServerInfo\", res);\n                this.loadingServerInfo = false;\n                return res;\n            }\n        }\n    }\n})();\n\n//https://stackoverflow.com/questions/40510611/typescript-interface-require-one-of-two-properties-to-exist\n//name describes what it does, makes the passed type only require 1 property, the others being optional\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, Exclude<keyof T, Keys>> &\n    {\n        [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, Exclude<Keys, K>>>;\n    }[Keys];\n","import { ApiClient } from \"./_base\";\nimport { AdministrationRights, InstanceManagerRights } from \"./generatedcode/_enums\";\nimport {\n    ErrorMessageResponse,\n    PaginatedUserResponse,\n    UserCreateRequest,\n    UserResponse,\n    UserUpdateRequest\n} from \"./generatedcode/schemas\";\nimport InternalError, { ErrorCode, GenericErrors } from \"./models/InternalComms/InternalError\";\nimport InternalStatus, { StatusCode } from \"./models/InternalComms/InternalStatus\";\nimport ServerClient from \"./ServerClient\";\nimport configOptions from \"./util/config\";\nimport CredentialsProvider from \"./util/CredentialsProvider\";\nimport LoginHooks from \"./util/LoginHooks\";\n\ninterface IEvents {\n    loadUserInfo: (user: InternalStatus<UserResponse, GenericErrors>) => void;\n}\n\nexport type GetCurrentUserErrors = GenericErrors;\nexport type EditUserErrors = GenericErrors | ErrorCode.USER_NOT_FOUND | GetCurrentUserErrors;\nexport type GetUserErrors = GenericErrors | ErrorCode.USER_NOT_FOUND;\nexport type CreateUserErrors = GenericErrors | ErrorCode.USER_NO_SYS_IDENT;\n\nexport default new (class UserClient extends ApiClient<IEvents> {\n    private _cachedUser?: InternalStatus<UserResponse, ErrorCode.OK>;\n    public get cachedUser() {\n        return this._cachedUser;\n    }\n    private loadingUserInfo = false;\n    //If set to true, all created users will default to having all permissions granted, used by the setup\n    public createAllUsersWithAA = false;\n\n    public constructor() {\n        super();\n        this.getCurrentUser = this.getCurrentUser.bind(this);\n\n        LoginHooks.addHook(() => this.getCurrentUser());\n        ServerClient.on(\"purgeCache\", () => {\n            this._cachedUser = undefined;\n        });\n    }\n\n    public async editUser(\n        newUser: UserUpdateRequest\n    ): Promise<InternalStatus<UserResponse, EditUserErrors>> {\n        await ServerClient.wait4Init();\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_Update(null, newUser);\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<EditUserErrors>\n            });\n        }\n        // noinspection DuplicatedCode\n        switch (response.status) {\n            case 200: {\n                const current = await this.getCurrentUser();\n                if (current.code == StatusCode.OK) {\n                    if (current.payload.id == newUser.id) {\n                        //if we are editing ourselves, clear cached data to reload permissions on the app\n                        ServerClient.emit(\"purgeCache\");\n                    }\n                } else {\n                    return new InternalStatus({\n                        code: StatusCode.ERROR,\n                        error: current.error\n                    });\n                }\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n            }\n            case 404: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NOT_FOUND, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getCurrentUser(\n        bypassCache?: boolean\n    ): Promise<InternalStatus<UserResponse, GetCurrentUserErrors>> {\n        await ServerClient.wait4Init();\n\n        if (!CredentialsProvider.isTokenValid()) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: new InternalError(ErrorCode.HTTP_ACCESS_DENIED, {\n                    void: true\n                })\n            });\n        }\n\n        if (this._cachedUser && !bypassCache) {\n            return this._cachedUser;\n        }\n\n        if (this.loadingUserInfo) {\n            return await new Promise(resolve => {\n                const resolver = (user: InternalStatus<UserResponse, GenericErrors>) => {\n                    resolve(user);\n                    this.removeListener(\"loadUserInfo\", resolver);\n                };\n                this.on(\"loadUserInfo\", resolver);\n            });\n        }\n\n        this.loadingUserInfo = true;\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_Read();\n        } catch (stat) {\n            const res = new InternalStatus<UserResponse, GenericErrors>({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n            this.emit(\"loadUserInfo\", res);\n            this.loadingUserInfo = false;\n            return res;\n        }\n\n        switch (response.status) {\n            case 200: {\n                const thing = new InternalStatus<UserResponse, ErrorCode.OK>({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n\n                this._cachedUser = thing;\n                this.emit(\"loadUserInfo\", thing);\n                this.loadingUserInfo = false;\n                return thing;\n            }\n            default: {\n                const res = new InternalStatus<UserResponse, ErrorCode.UNHANDLED_RESPONSE>({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n                this.emit(\"loadUserInfo\", res);\n                this.loadingUserInfo = false;\n                return res;\n            }\n        }\n    }\n\n    public async listUsers({\n        page = 1,\n        pageSize = configOptions.itemsperpage.value as number\n    }): Promise<InternalStatus<PaginatedUserResponse, GenericErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_List({\n                page: page,\n                pageSize: pageSize\n            });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 200: {\n                const payload = (response.data as PaginatedUserResponse).content.sort(\n                    (a, b) => a.id - b.id\n                );\n\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: {\n                        ...(response.data as PaginatedUserResponse),\n                        content: payload\n                    }\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async getUser(id: number): Promise<InternalStatus<UserResponse, GetUserErrors>> {\n        await ServerClient.wait4Init();\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_GetId({ id: id });\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n        // noinspection DuplicatedCode\n        switch (response.status) {\n            case 200: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n            }\n            case 404: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NOT_FOUND, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n\n    public async createUser(\n        newuser:\n            | {\n                  name: string;\n                  password: string;\n                  enabled?: boolean;\n                  instanceManagerRights?: InstanceManagerRights;\n                  administrationRights?: AdministrationRights;\n              }\n            | {\n                  systemIdentifier: string;\n                  enabled?: boolean;\n                  instanceManagerRights?: InstanceManagerRights;\n                  administrationRights?: AdministrationRights;\n              }\n    ): Promise<InternalStatus<UserResponse, CreateUserErrors>> {\n        await ServerClient.wait4Init();\n\n        if (newuser.enabled === undefined) newuser.enabled = true;\n        if (this.createAllUsersWithAA) {\n            newuser.instanceManagerRights = 0;\n            newuser.administrationRights = 0;\n\n            for (const perm of Object.values(InstanceManagerRights)) {\n                if (typeof perm !== \"number\") continue;\n                newuser.instanceManagerRights += perm;\n            }\n\n            for (const perm of Object.values(AdministrationRights)) {\n                if (typeof perm !== \"number\") continue;\n                newuser.administrationRights += perm;\n            }\n        }\n\n        let response;\n        try {\n            response = await ServerClient.apiClient!.UserController_Create(\n                null,\n                newuser as UserCreateRequest\n            );\n        } catch (stat) {\n            return new InternalStatus({\n                code: StatusCode.ERROR,\n                error: stat as InternalError<GenericErrors>\n            });\n        }\n\n        switch (response.status) {\n            case 201: {\n                return new InternalStatus({\n                    code: StatusCode.OK,\n                    payload: response.data as UserResponse\n                });\n            }\n            case 410: {\n                const errorMessage = response.data as ErrorMessageResponse;\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(ErrorCode.USER_NO_SYS_IDENT, { errorMessage })\n                });\n            }\n            default: {\n                return new InternalStatus({\n                    code: StatusCode.ERROR,\n                    error: new InternalError(\n                        ErrorCode.UNHANDLED_RESPONSE,\n                        { axiosResponse: response },\n                        response\n                    )\n                });\n            }\n        }\n    }\n})();\n","import { DefaultListener, ListenerSignature, TypedEmitter } from \"tiny-typed-emitter\";\n\nexport abstract class ApiClient<\n    L extends ListenerSignature<L> = DefaultListener\n> extends TypedEmitter<L> {\n    public constructor() {\n        super();\n        if (window.clients == undefined) window.clients = {};\n        console.log(this.constructor.name, this);\n        window.clients[this.constructor.name] = this;\n    }\n}\n","export enum AdministrationRights {\n   None = 0,\n   WriteUsers = 1,\n   RestartHost = 2,\n   ChangeVersion = 4,\n   EditOwnPassword = 8,\n   ReadUsers = 16,\n   DownloadLogs = 32,\n   EditOwnOAuthConnections = 64\n}\n\nexport enum ByondRights {\n   None = 0,\n   ReadActive = 1,\n   ListInstalled = 2,\n   InstallOfficialOrChangeActiveVersion = 4,\n   CancelInstall = 8,\n   InstallCustomVersion = 16\n}\n\nexport enum ChatBotRights {\n   None = 0,\n   WriteEnabled = 1,\n   WriteProvider = 2,\n   WriteChannels = 4,\n   WriteConnectionString = 8,\n   ReadConnectionString = 16,\n   Read = 32,\n   Create = 64,\n   Delete = 128,\n   WriteName = 256,\n   WriteReconnectionInterval = 512,\n   WriteChannelLimit = 1024\n}\n\nexport enum ChatProvider {\n   Irc = 0,\n   Discord = 1\n}\n\nexport enum ConfigurationRights {\n   None = 0,\n   Read = 1,\n   Write = 2,\n   List = 4,\n   Delete = 8\n}\n\nexport enum ConfigurationType {\n   Disallowed = 0,\n   HostWrite = 1,\n   SystemIdentityWrite = 2\n}\n\nexport enum DreamDaemonRights {\n   None = 0,\n   ReadRevision = 1,\n   SetPort = 2,\n   SetAutoStart = 4,\n   SetSecurity = 8,\n   ReadMetadata = 16,\n   SetWebClient = 32,\n   SoftRestart = 64,\n   SoftShutdown = 128,\n   Restart = 256,\n   Shutdown = 512,\n   Start = 1024,\n   SetStartupTimeout = 2048,\n   SetHeartbeatInterval = 4096,\n   CreateDump = 8192,\n   SetTopicTimeout = 16384,\n   SetAdditionalParameters = 32768,\n   SetVisibility = 65536\n}\n\nexport enum DreamDaemonSecurity {\n   Trusted = 0,\n   Safe = 1,\n   Ultrasafe = 2\n}\n\nexport enum DreamDaemonVisibility {\n   Public = 0,\n   Private = 1,\n   Invisible = 2\n}\n\nexport enum DreamMakerRights {\n   None = 0,\n   Read = 1,\n   Compile = 2,\n   CancelCompile = 4,\n   SetDme = 8,\n   SetApiValidationPort = 16,\n   CompileJobs = 32,\n   SetSecurityLevel = 64,\n   SetApiValidationRequirement = 128,\n   SetTimeout = 256\n}\n\nexport enum ErrorCode {\n   InternalServerError = 0,\n   ApiMismatch = 1,\n   ModelValidationFailure = 2,\n   IOError = 3,\n   BadHeaders = 4,\n   TokenWithToken = 5,\n   DatabaseIntegrityConflict = 6,\n   MissingHostWatchdog = 7,\n   CannotChangeServerSuite = 8,\n   RemoteApiError = 9,\n   ServerUpdateInProgress = 10,\n   UserNameChange = 11,\n   UserSidChange = 12,\n   UserMismatchNameSid = 13,\n   UserMismatchPasswordSid = 14,\n   UserPasswordLength = 15,\n   UserColonInName = 16,\n   UserMissingName = 17,\n   InstanceRelocateOnline = 18,\n   InstanceAtExistingPath = 19,\n   InstanceDetachOnline = 20,\n   InstanceAtConflictingPath = 21,\n   InstanceLimitReached = 22,\n   InstanceWhitespaceName = 23,\n   InstanceHeaderRequired = 24,\n   RequiresPosixSystemIdentity = 25,\n   ConfigurationFileUpdated = 26,\n   ConfigurationDirectoryNotEmpty = 27,\n   DEPRECATED_UnusedErrorCode1 = 28,\n   RepoMismatchUserAndAccessToken = 29,\n   RepoCloning = 30,\n   RepoBusy = 31,\n   RepoExists = 32,\n   RepoMissing = 33,\n   RepoMismatchShaAndReference = 34,\n   RepoMismatchShaAndUpdate = 35,\n   DEPRECATED_UnusedErrorCode2 = 36,\n   RepoDuplicateTestMerge = 37,\n   RepoWhitespaceCommitterName = 38,\n   RepoWhitespaceCommitterEmail = 39,\n   ApiPageTooLarge = 40,\n   ApiInvalidPageOrPageSize = 41,\n   ChatBotWrongChannelType = 42,\n   ChatBotWhitespaceConnectionString = 43,\n   ChatBotWhitespaceName = 44,\n   ChatBotProviderMissing = 45,\n   DEPRECATED_UnusedErrorCode3 = 46,\n   ChatBotMax = 47,\n   ChatBotMaxChannels = 48,\n   ByondDirectXInstallFail = 49,\n   ByondDownloadFail = 50,\n   ByondNoVersionsInstalled = 51,\n   DreamMakerNeverValidated = 52,\n   DreamMakerInvalidValidation = 53,\n   CannotRemoveLastAuthenticationOption = 54,\n   DreamMakerNoDme = 55,\n   DreamMakerMissingDme = 56,\n   DreamMakerExitCode = 57,\n   DreamMakerCompileJobInProgress = 58,\n   InstanceMissingDreamDaemonSettings = 59,\n   InstanceMissingDreamMakerSettings = 60,\n   InstanceMissingRepositorySettings = 61,\n   InstanceUpdateTestMergeConflict = 62,\n   RepoCredentialsRequired = 63,\n   RepoCannotAuthenticate = 64,\n   RepoReferenceRequired = 65,\n   WatchdogRunning = 66,\n   WatchdogCompileJobCorrupted = 67,\n   WatchdogStartupFailed = 68,\n   WatchdogStartupTimeout = 69,\n   RepoUnsupportedTestMergeRemote = 70,\n   RepoSwappedShaOrReference = 71,\n   RepoMergeConflict = 72,\n   RepoReferenceNotTracking = 73,\n   RepoTestMergeConflict = 74,\n   InstanceNotAtWhitelistedPath = 75,\n   DreamDaemonDoubleSoft = 76,\n   DeploymentPagerRunning = 77,\n   DreamDaemonPortInUse = 78,\n   PostDeployFailure = 79,\n   WatchdogNotRunning = 80,\n   ResourceNotPresent = 81,\n   ResourceNeverPresent = 82,\n   GitHubApiRateLimit = 83,\n   JobStopped = 84,\n   MissingGCore = 85,\n   GCoreFailure = 86,\n   RepoTestMergeInvalidRemote = 87,\n   ByondNonExistentCustomVersion = 88,\n   DreamDaemonOffline = 89,\n   InstanceOffline = 90,\n   ChatCannotConnectProvider = 91,\n   ByondDreamDaemonFirewallFail = 92,\n   NoPortsAvailable = 93,\n   PortNotAvailable = 94,\n   AdminUserCannotOAuth = 95,\n   OAuthProviderDisabled = 96,\n   FileUploadExpired = 97,\n   UserGroupAndPermissionSet = 98,\n   UserGroupNotEmpty = 99,\n   UserLimitReached = 100,\n   UserGroupLimitReached = 101,\n   DeploymentTimeout = 102\n}\n\nexport enum InstanceManagerRights {\n   None = 0,\n   Read = 1,\n   Create = 2,\n   Rename = 4,\n   Relocate = 8,\n   SetOnline = 16,\n   Delete = 32,\n   List = 64,\n   SetConfiguration = 128,\n   SetAutoUpdate = 256,\n   SetChatBotLimit = 512,\n   GrantPermissions = 1024\n}\n\nexport enum InstancePermissionSetRights {\n   None = 0,\n   Read = 1,\n   Write = 2,\n   Create = 4\n}\n\nexport enum OAuthProvider {\n   GitHub = \"GitHub\",\n   Discord = \"Discord\",\n   TGForums = \"TGForums\",\n   Keycloak = \"Keycloak\"\n}\n\nexport enum RemoteGitProvider {\n   Unknown = 0,\n   GitHub = 1,\n   GitLab = 2\n}\n\nexport enum RepositoryRights {\n   None = 0,\n   CancelPendingChanges = 1,\n   SetOrigin = 2,\n   SetSha = 4,\n   MergePullRequest = 8,\n   UpdateBranch = 16,\n   ChangeCommitter = 32,\n   ChangeTestMergeCommits = 64,\n   ChangeCredentials = 128,\n   SetReference = 256,\n   Read = 512,\n   ChangeAutoUpdateSettings = 1024,\n   Delete = 2048,\n   CancelClone = 4096,\n   ChangeSubmoduleUpdate = 8192\n}\n\nexport enum RightsType {\n   Administration = 0,\n   InstanceManager = 1,\n   Repository = 2,\n   Byond = 3,\n   DreamMaker = 4,\n   DreamDaemon = 5,\n   ChatBots = 6,\n   Configuration = 7,\n   InstancePermissionSet = 8\n}\n\nexport enum WatchdogStatus {\n   Offline = 0,\n   Restoring = 1,\n   Online = 2,\n   DelayedRestart = 3\n}\n\n","import { OAuthProvider } from \"../generatedcode/_enums\";\n\nexport enum CredentialsType {\n    Password,\n    OAuth\n}\n\nexport interface IPasswordCredentials {\n    type: CredentialsType.Password;\n    userName: string;\n    password: string;\n}\n\nexport interface IOAuthCredentials {\n    type: CredentialsType.OAuth;\n    provider: OAuthProvider;\n    token: string;\n}\n\nexport type ICredentials = IPasswordCredentials | IOAuthCredentials;\n","import { AxiosResponse } from \"axios\";\n\nimport { replaceAll } from \"../../../utils/misc\";\nimport { ErrorCode as TGSErrorCode } from \"../../generatedcode/_enums\";\nimport { ErrorMessageResponse } from \"../../generatedcode/schemas\";\nimport configOptions from \"../../util/config\";\nimport CredentialsProvider from \"../../util/CredentialsProvider\";\n\nexport type GenericErrors =\n    | ErrorCode.HTTP_BAD_REQUEST\n    | ErrorCode.HTTP_DATA_INEGRITY\n    | ErrorCode.HTTP_API_MISMATCH\n    | ErrorCode.HTTP_SERVER_ERROR\n    | ErrorCode.HTTP_UNIMPLEMENTED\n    //    | ErrorCode.HTTP_SERVER_NOT_READY\n    | ErrorCode.AXIOS\n    | ErrorCode.UNHANDLED_RESPONSE\n    | ErrorCode.UNHANDLED_GLOBAL_RESPONSE\n    | ErrorCode.HTTP_ACCESS_DENIED\n    | ErrorCode.HTTP_NOT_ACCEPTABLE\n    | ErrorCode.OK\n    | ErrorCode.NO_APIPATH\n    | ErrorCode.APP_FAIL;\n\nexport enum ErrorCode {\n    OK = 'Isnt displayed but is used as an \"error\" when everything is ok', //void\n    HTTP_BAD_REQUEST = \"error.http.bad_request\", //errmessage\n    HTTP_DATA_INEGRITY = \"error.http.data_integrity\", //errmessage\n    HTTP_API_MISMATCH = \"error.http.api_mismatch\", //void\n    HTTP_SERVER_ERROR = \"error.http.server_error\", //errmessage\n    HTTP_UNIMPLEMENTED = \"error.http.unimplemented\", //errmessage\n    //auto retry    HTTP_SERVER_NOT_READY = 'error.http.server_not_ready', //void\n    HTTP_ACCESS_DENIED = \"error.http.access_denied\", //void\n    HTTP_NOT_ACCEPTABLE = \"error.http.not_acceptable\", //void\n    UNHANDLED_RESPONSE = \"error.unhandled_response\", //axiosresponse\n    UNHANDLED_GLOBAL_RESPONSE = \"error.unhandled_global_response\", //axiosresponse\n    AXIOS = \"error.axios\", //jserror\n\n    //Generic errors\n    GITHUB_FAIL = \"error.github\", //jserror\n    APP_FAIL = \"error.app\", //jserror\n    NO_APIPATH = \"error.no_apipath\", //void\n\n    //Login errors\n    LOGIN_FAIL = \"error.login.bad_user_pass\", //void\n    LOGIN_NOCREDS = \"error.login.no_creds\", //void\n    LOGIN_DISABLED = \"error.login.user_disabled\", //void\n    LOGIN_BAD_OAUTH = \"error.login.bad_oauth\", //jserror\n    LOGIN_RATELIMIT = \"error.login.rate_limit\", //errmessage\n\n    //User errors\n    USER_NO_SYS_IDENT = \"error.user.no_sys_ident\", //errmessage\n    USER_NOT_FOUND = \"error.user.not_found\", //errmessage\n\n    //Administration errors\n    ADMIN_GITHUB_RATE = \"error.admin.rate\", //errmessage\n    ADMIN_GITHUB_ERROR = \"error.admin.error\", //errmessage\n    ADMIN_WATCHDOG_UNAVAIL = \"error.admin.watchdog.avail\", //errmessage\n    ADMIN_VERSION_NOT_FOUND = \"error.admin.update.notfound\", //errmessage\n    ADMIN_LOGS_IO_ERROR = \"error.admin.logs.io\", //errmessage\n\n    //Job errors\n    JOB_JOB_NOT_FOUND = \"error.job.not_found\", //errmessage\n    JOB_JOB_COMPLETE = \"error.job.complete\", //void\n\n    //Transfer errors\n    TRANSFER_NOT_AVAILABLE = \"error.transfer.not_available\", //errmessage\n    UPLOAD_FAILED = \"error.transfer.upload_failed\", //void\n\n    GROUP_NOT_FOUND = \"error.group.not_found\", //errmessage\n    GROUP_NOT_EMPTY = \"error.group.not_empty\", //errmessage\n\n    //Instance errors\n    INSTANCE_NO_DB_ENTITY = \"error.instance.no_db_entity\", //errmessage\n\n    //Watchdog errors\n    WATCHDOG_NO_DB_ENTITY = \"error.watchdog.no_db_entity\" //errmessage\n}\n\ntype errorMessage = {\n    errorMessage: ErrorMessageResponse;\n};\ntype axiosResponse = {\n    axiosResponse: AxiosResponse;\n};\ntype jsError = {\n    jsError: Error;\n};\ntype voidError = {\n    void: true;\n};\n\nexport enum DescType {\n    LOCALE,\n    TEXT\n}\ninterface Desc {\n    type: DescType;\n    desc: string;\n}\n\ntype allAddons = errorMessage | axiosResponse | jsError | voidError;\n\nexport default class InternalError<T extends ErrorCode = ErrorCode> {\n    public readonly code: T;\n    public readonly desc?: Desc;\n    public readonly extendedInfo: string;\n    public readonly originalErrorMessage?: ErrorMessageResponse;\n\n    public constructor(code: T, addon: allAddons, origin?: AxiosResponse) {\n        this.code = code;\n        if (\"errorMessage\" in addon) {\n            const err = addon.errorMessage;\n            this.originalErrorMessage = err;\n            this.desc = {\n                type: DescType.TEXT,\n                desc:\n                    TGSErrorCode[err.errorCode] +\n                    \": \" +\n                    err.message +\n                    (err.additionalData ? \": \" + err.additionalData : \"\")\n            };\n            if (!err.message) {\n                this.desc = {\n                    type: DescType.TEXT,\n                    desc: TGSErrorCode[err.errorCode]\n                };\n            }\n        }\n        if (\"jsError\" in addon) {\n            const err = addon.jsError;\n            this.desc = {\n                type: DescType.TEXT,\n                desc: `${err.name}: ${err.message}`\n            };\n        }\n        const stack = new Error().stack;\n\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n        if (origin?.config.headers[\"Authorization\"]) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            origin.config.headers[\"Authorization\"] = \"*********\";\n        }\n\n        let debuginfo = JSON.stringify({ addon, origin, config: configOptions, stack });\n        debuginfo = debuginfo.replace(\n            /Basic (?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?/g,\n            \"Basic **************\"\n        );\n        debuginfo = debuginfo.replace(\n            /{\"username\":\".+?\",\"password\":\".+?\"}/g,\n            '{\"username\":\"*******\",\"password\":\"*******\"}'\n        );\n        if (CredentialsProvider.isTokenValid()) {\n            debuginfo = replaceAll(\n                debuginfo,\n                CredentialsProvider.token?.bearer as string,\n                \"**************\"\n            );\n        }\n        if (configOptions.githubtoken.value) {\n            debuginfo = replaceAll(\n                debuginfo,\n                configOptions.githubtoken.value as string,\n                \"**************\"\n            );\n        }\n        this.extendedInfo = debuginfo;\n\n        console.error(\n            `Error occured within the application: ${this.code} (${\n                this.desc?.desc ?? \"No description\"\n            })`,\n            this\n        );\n\n        //@ts-expect-error yeah well, i aint extending the window interface\n        if (window.breakonerror) {\n            // eslint-disable-next-line no-debugger\n            debugger;\n        }\n    }\n}\n","import InternalError, { ErrorCode } from \"./InternalError\";\n\nexport enum StatusCode {\n    OK,\n    ERROR\n}\n\nexport interface InternalStatusErr<Codes extends ErrorCode> {\n    code: StatusCode.ERROR;\n    error: InternalError<Codes>;\n}\n\nexport interface InternalStatusOK<T> {\n    code: StatusCode.OK;\n    payload: T;\n}\n\ntype InternalStatus<T, Codes extends ErrorCode> = InternalStatusOK<T> | InternalStatusErr<Codes>;\n\nconst InternalStatus = function InternalStatus<T, Codes extends ErrorCode>(\n    this: InternalStatus<T, Codes>,\n    args: InternalStatus<T, Codes>\n): Readonly<InternalStatus<T, Codes>> {\n    return Object.freeze(Object.assign({}, args));\n} as unknown as {\n    new <T, Codes extends ErrorCode>(args: InternalStatus<T, Codes>): Readonly<\n        InternalStatus<T, Codes>\n    >;\n};\n\nexport default InternalStatus;\n","import configOptions, { ConfigOption, ConfigValue } from \"./config\";\n\nexport default new (class ConfigController {\n    public loadconfig() {\n        for (const val of Object.values(configOptions)) {\n            this.getconfig(val);\n        }\n        console.log(\"Configuration loaded\", configOptions);\n    }\n\n    public saveconfig(newconfig: Partial<typeof configOptions>) {\n        for (const [key, val] of Object.entries(newconfig)) {\n            this.setconfig(key as keyof typeof configOptions, val);\n        }\n        console.log(\"Configuration saved\", configOptions);\n    }\n\n    private setconfig(key: keyof typeof configOptions, option: ConfigOption) {\n        if (option?.value === undefined) return this.deleteconfig(key);\n\n        //safeties\n        switch (option.type) {\n            case \"num\": {\n                //this parses strings and numbers alike to numbers and refuses non numbers\n                //@ts-expect-error //parseInt can take numbers\n                const value = parseInt(option.value);\n                if (Number.isNaN(option.value)) return;\n                if (option.min !== undefined && value < option.min) return;\n                if (option.max !== undefined && value > option.max) return;\n                option.value = value;\n                break;\n            }\n        }\n\n        if (option.callback) {\n            // @ts-expect-error Can't be assed to figure this one out\n            option.callback(configOptions[key].value, option.value);\n        }\n        configOptions[key].value = option.value;\n        //configOptions[key].persist = option.persist;\n\n        //if (!option.persist) return this.deleteconfig(key); //idiot proofing, alexkar proofing\n\n        try {\n            localStorage.setItem(option.id, JSON.stringify(option.value));\n            //option.persist = true;\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n\n    private getconfig(option: ConfigOption): void {\n        try {\n            const data = localStorage.getItem(option.id);\n            if (data !== undefined && data !== null) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                const json = JSON.parse(data);\n                if (json !== null && json !== undefined) {\n                    option.value = json as ConfigValue;\n                }\n                //option.persist = true;\n            }\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n\n    private deleteconfig(key: keyof typeof configOptions): void {\n        try {\n            const option = configOptions[key];\n            localStorage.removeItem(option.id);\n            //option.persist = false;\n        } catch (e) {\n            (() => {})(); //noop\n        }\n    }\n})();\n","import { MODE } from \"../../definitions/constants\";\nimport { TokenResponse } from \"../generatedcode/schemas\";\nimport { ICredentials } from \"../models/ICredentials\";\n\n//Data structure meant to help against circular dependencies within the ApiClient\n//Its rather dumb and only holds username, password and the token.\n//Also contains a function to determine if theres a token here\nexport default new (class CredentialsProvider {\n    //token\n    public token?: TokenResponse;\n\n    //credentials\n    public credentials?: ICredentials;\n\n    public isTokenValid() {\n        return (\n            this.credentials && this.token && this.token.bearer /* &&\n            (!this.token.expiresAt || new Date(this.token.expiresAt) > new Date(Date.now()))*/\n        );\n    }\n\n    public constructor() {\n        if (MODE === \"DEV\") {\n            window.credentialProvider = this;\n        }\n    }\n})();\n","import { satisfies as SemverSatisfies } from \"semver\";\nimport { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { resolvePermissionSet } from \"../../utils/misc\";\nimport {\n    AdministrationRights,\n    ByondRights,\n    ChatBotRights,\n    ConfigurationRights,\n    DreamDaemonRights,\n    DreamMakerRights,\n    ErrorCode as TGSErrorCode,\n    InstanceManagerRights,\n    InstancePermissionSetRights,\n    RepositoryRights,\n    RightsType\n} from \"../generatedcode/_enums\";\nimport { InstanceResponse } from \"../generatedcode/schemas\";\nimport InstanceClient from \"../InstanceClient\";\nimport InstancePermissionSetClient from \"../InstancePermissionSetClient\";\nimport JobsClient, { TGSJobResponse } from \"../JobsClient\";\nimport InternalError, { ErrorCode } from \"../models/InternalComms/InternalError\";\nimport { StatusCode } from \"../models/InternalComms/InternalStatus\";\nimport ServerClient from \"../ServerClient\";\nimport UserClient from \"../UserClient\";\nimport configOptions from \"./config\";\nimport LoginHooks from \"./LoginHooks\";\n\ninterface IEvents {\n    jobsLoaded: () => unknown;\n}\n\nexport default new (class JobsController extends TypedEmitter<IEvents> {\n    private fastmodecount = 0;\n    public set fastmode(cycles: number) {\n        console.log(`JobsController going in fastmode for ${cycles} cycles`);\n        this.fastmodecount = cycles;\n        this.restartLoop();\n    }\n\n    private currentLoop: Date = new Date(0);\n    private accessibleInstances = new Set<number>();\n\n    private enableJobProgressWorkaround?: boolean;\n\n    public errors: InternalError[] = [];\n    public jobs = new Map<number, TGSJobResponse>();\n    public jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n    private jobCallback = new Map<number, Set<(job: TGSJobResponse) => unknown>>();\n\n    public reset() {\n        this.jobs = new Map<number, TGSJobResponse>();\n        this.jobsByInstance = new Map<number, Map<number, TGSJobResponse>>();\n        this.reloadAccessibleInstances()\n            .then(this.restartLoop)\n            .catch(e => {\n                this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }));\n            });\n    }\n\n    public constructor() {\n        super();\n\n        this.loop = this.loop.bind(this);\n        this.reset = this.reset.bind(this);\n        this.restartLoop = this.restartLoop.bind(this);\n    }\n\n    public init() {\n        window.clients[\"JobsController\"] = this;\n\n        //technically not a \"cache\" but we might as well reload it\n        ServerClient.on(\"purgeCache\", this.reset);\n\n        InstanceClient.on(\"instanceChange\", this.reset);\n        // eslint-disable-next-line @typescript-eslint/require-await\n        LoginHooks.addHook(async () => this.reset());\n\n        ServerClient.getServerInfo()\n            .then(response => {\n                if (response.code === StatusCode.OK) {\n                    //A bug in versions below 4.11.0 makes it so that /Job/List doesn't report back progress. If we are running on a higher version, theres no point in enabling the workaround\n                    this.enableJobProgressWorkaround = SemverSatisfies(\n                        response.payload.version,\n                        \"<4.11.0\"\n                    );\n                }\n            })\n            .catch(e => console.error(e));\n    }\n\n    private async reloadAccessibleInstances(loop = false): Promise<void> {\n        const allInstances: InstanceResponse[] = [];\n\n        const instances1 = await InstanceClient.listInstances({ pageSize: 100 });\n        if (instances1.code === StatusCode.ERROR) {\n            this.errors.push(instances1.error);\n            return;\n        } else {\n            allInstances.push(...instances1.payload.content);\n        }\n        for (let i = 2; i <= instances1.payload.totalPages; i++) {\n            const instances2 = await InstanceClient.listInstances({ page: i, pageSize: 100 });\n            if (instances2.code === StatusCode.ERROR) {\n                this.errors.push(instances2.error);\n                return;\n            } else {\n                allInstances.push(...instances2.payload.content);\n            }\n        }\n\n        const updatedSet = new Set<number>();\n\n        const work = allInstances\n            .filter(instance => instance.online)\n            .map(instance => {\n                return InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                    instance.id\n                ).then(permissionSet => {\n                    if (permissionSet.code === StatusCode.ERROR) {\n                        //If its access denied, it means we have view all instances but we dont have access to the instance itself\n                        if (permissionSet.error.code !== ErrorCode.HTTP_ACCESS_DENIED) {\n                            this.errors.push(permissionSet.error);\n                        }\n                        return;\n                    }\n                    updatedSet.add(instance.id);\n                });\n            });\n\n        await Promise.all(work);\n\n        this.accessibleInstances = updatedSet;\n\n        if (loop) {\n            window.setTimeout(\n                () => void this.reloadAccessibleInstances(true),\n                configOptions.instanceprobetimer.value as number\n            );\n        }\n    }\n\n    public restartLoop() {\n        //we use an actual date object here because it could help prevent really weird timing\n        // issues as two different date objects cannot be equal\n        // despite the date being\n        const initDate = new Date(Date.now());\n        this.currentLoop = initDate;\n        window.setTimeout(() => {\n            this.loop(initDate).catch(e =>\n                this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n            );\n        }, 0);\n    }\n\n    private async loop(loopid: Date) {\n        //so loops get initialiazed with the current time, it keeps track of which loop to run with\n        // that initialization date in currentLoop if the currentLoop isnt equal to the one provided\n        // to the loop, it means that the loop was\n        // replaced so we dont try to call for another one\n        if (loopid !== this.currentLoop) {\n            return;\n        }\n\n        //time to clear out errors\n        this.errors = [];\n\n        let totalActiveJobs = 0;\n        const work: Promise<void>[] = [];\n\n        this.accessibleInstances.forEach(instanceid => {\n            const processJobs = async (jobs: TGSJobResponse[]) => {\n                const instanceSet = this.jobsByInstance.get(instanceid) ?? new Map();\n                this.jobsByInstance.set(instanceid, instanceSet);\n                for (const job of jobs) {\n                    instanceSet.set(job.id, job);\n                    this.jobs.set(job.id, job);\n                }\n\n                const remoteActive = jobs.map(job => job.id);\n                const localActive = Array.from(this.jobs.values())\n                    .filter(job => !job.stoppedAt)\n                    .filter(job => job.instanceid === instanceid)\n                    .map(job => job.id);\n                const manualIds = localActive.filter(jobId => !remoteActive.includes(jobId));\n\n                const work: Promise<void>[] = [];\n                manualIds.forEach(jobId => {\n                    work.push(\n                        JobsClient.getJob(instanceid, jobId).then(job => {\n                            if (job.code === StatusCode.ERROR) {\n                                this.errors.push(job.error);\n                                return;\n                            }\n                            instanceSet.set(job.payload.id, job.payload);\n                            this.jobs.set(job.payload.id, job.payload);\n                        })\n                    );\n                });\n                await Promise.all(work);\n\n                if (loopid !== this.currentLoop) return;\n\n                totalActiveJobs += jobs.length;\n            };\n\n            const processError = (error: InternalError) => {\n                if (\n                    error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                    error.originalErrorMessage?.errorCode === TGSErrorCode.InstanceOffline\n                ) {\n                    console.log(\n                        `[JobsController] Clearing instance ${instanceid} as it is now offline`\n                    );\n                    this.accessibleInstances.delete(instanceid);\n                    //Probably a good idea to reload the list at this point\n                    this.reloadAccessibleInstances().catch(e => {\n                        this.errors.push(\n                            new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) })\n                        );\n                    });\n                } else {\n                    this.errors.push(error);\n                }\n            };\n\n            //now since this is async, it still possible that a single fire gets done after the new loop started, theres no really much that can be done about it\n            work.push(\n                JobsClient.listActiveJobs(instanceid, { page: 1, pageSize: 100 })\n                    .then(async value => {\n                        //this check is here because the request itself is async and could return after\n                        // the loop is terminated, we dont want to contaminate the jobs of an instance\n                        // with the jobs of another even if it is for a single fire and would eventually\n                        // get fixed on its own after a few seconds\n                        if (loopid !== this.currentLoop) return;\n\n                        if (value.code === StatusCode.OK) {\n                            for (let i = 2; i <= value.payload.totalPages; i++) {\n                                const jobs2 = await JobsClient.listActiveJobs(instanceid, {\n                                    page: i,\n                                    pageSize: 100\n                                });\n                                if (jobs2.code === StatusCode.ERROR) {\n                                    processError(jobs2.error);\n                                    return;\n                                } else {\n                                    value.payload.content.push(...jobs2.payload.content);\n                                }\n                            }\n                            if (loopid !== this.currentLoop) return;\n                            await processJobs(value.payload.content);\n                        } else {\n                            processError(value.error);\n                        }\n                    })\n                    .catch(reason => {\n                        console.error(reason);\n                    })\n            );\n        });\n\n        await Promise.all(work);\n\n        work.length = 0;\n        for (const job of this.jobs.values()) {\n            if (\n                this.enableJobProgressWorkaround &&\n                job.progress === undefined &&\n                !job.stoppedAt &&\n                this.accessibleInstances.has(job.instanceid)\n            ) {\n                work.push(\n                    JobsClient.getJob(job.instanceid, job.id).then(progressedjob => {\n                        if (loopid !== this.currentLoop) return;\n                        if (progressedjob.code === StatusCode.OK) {\n                            job.progress = progressedjob.payload.progress;\n                        } else {\n                            if (\n                                progressedjob.error.code === ErrorCode.HTTP_DATA_INEGRITY &&\n                                progressedjob.error.originalErrorMessage?.errorCode ===\n                                    TGSErrorCode.InstanceOffline\n                            ) {\n                                console.log(\n                                    `[JobsController] Clearing instance ${job.instanceid} as it is now offline`\n                                );\n                                this.accessibleInstances.delete(job.instanceid);\n                                //Probably a good idea to reload the list at this point\n                                this.reloadAccessibleInstances().catch(e => {\n                                    this.errors.push(\n                                        new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) })\n                                    );\n                                });\n                            } else {\n                                this.errors.push(progressedjob.error);\n                            }\n                        }\n                    })\n                );\n            }\n\n            work.push(\n                this.canCancel(job, this.errors).then(canCancel => {\n                    if (loopid !== this.currentLoop) return;\n                    job.canCancel = canCancel;\n                })\n            );\n        }\n\n        //populate fields on jobs\n        await Promise.all(work);\n        if (loopid !== this.currentLoop) return;\n\n        this.emit(\"jobsLoaded\");\n\n        for (const job of this.jobs.values()) {\n            if (!job.stoppedAt) continue;\n            const callbacks = this.jobCallback.get(job.id);\n            if (!callbacks) continue;\n            for (const callback of callbacks) {\n                callback(job);\n            }\n            this.jobCallback.delete(job.id);\n        }\n\n        if (this.fastmodecount && loopid === this.currentLoop) {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, 800);\n            this.fastmodecount--;\n            console.log(`JobsController will remain in fastmode for ${this.fastmodecount} cycles`);\n        } else {\n            window.setTimeout(() => {\n                this.loop(loopid).catch(e =>\n                    this.errors.push(new InternalError(ErrorCode.APP_FAIL, { jsError: Error(e) }))\n                );\n            }, (totalActiveJobs ? (configOptions.jobpollactive.value as number) : (configOptions.jobpollinactive.value as number)) * 1000);\n        }\n    }\n\n    private async canCancel(\n        job: Readonly<TGSJobResponse>,\n        errors: InternalError<ErrorCode>[]\n    ): Promise<boolean> {\n        //we dont need to reevalutate stuff that we already know\n        if (job.canCancel !== undefined) return job.canCancel;\n\n        if (job.cancelRightsType === undefined) {\n            return true;\n        }\n\n        switch (job.cancelRightsType as RightsType) {\n            case RightsType.Administration: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as AdministrationRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).administrationRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.InstanceManager: {\n                const userInfo = await UserClient.getCurrentUser();\n                if (userInfo.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstanceManagerRights;\n                    return !!(\n                        resolvePermissionSet(userInfo.payload).instanceManagerRights & required\n                    );\n                } else {\n                    errors.push(userInfo.error);\n                    return false;\n                }\n            }\n            case RightsType.Byond: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ByondRights;\n                    return !!(InstancePermissionSet.payload.byondRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.ChatBots: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ChatBotRights;\n                    return !!(InstancePermissionSet.payload.chatBotRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Configuration: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as ConfigurationRights;\n                    return !!(InstancePermissionSet.payload.configurationRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamDaemon: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamDaemonRights;\n                    return !!(InstancePermissionSet.payload.dreamDaemonRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.DreamMaker: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as DreamMakerRights;\n                    return !!(InstancePermissionSet.payload.dreamMakerRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.InstancePermissionSet: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as InstancePermissionSetRights;\n                    return !!(InstancePermissionSet.payload.instancePermissionSetRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n            case RightsType.Repository: {\n                const InstancePermissionSet =\n                    await InstancePermissionSetClient.getCurrentInstancePermissionSet(\n                        job.instanceid\n                    );\n                if (InstancePermissionSet.code === StatusCode.OK) {\n                    const required = job.cancelRight as RepositoryRights;\n                    return !!(InstancePermissionSet.payload.repositoryRights & required);\n                } else {\n                    errors.push(InstancePermissionSet.error);\n                    return false;\n                }\n            }\n        }\n    }\n\n    public async cancelJob(\n        jobid: number,\n        onError: (error: InternalError<ErrorCode>) => void\n    ): Promise<boolean> {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        const deleteInfo = await JobsClient.deleteJob(job.instanceid, jobid);\n        if (deleteInfo.code === StatusCode.OK) {\n            return true;\n        } else {\n            onError(deleteInfo.error);\n            return false;\n        }\n    }\n\n    public clearJob(jobid: number): boolean {\n        const job = this.jobs.get(jobid);\n\n        //no we cant cancel jobs we arent aware of yet\n        if (!job) return false;\n\n        this.jobsByInstance.get(job.instanceid)?.delete(jobid);\n        this.jobs.delete(jobid);\n        this.emit(\"jobsLoaded\");\n        return true;\n    }\n\n    public registerCallback(jobid: number, callback: (job: TGSJobResponse) => unknown): void {\n        const set = this.jobCallback.get(jobid) ?? new Set();\n        set.add(callback);\n        this.jobCallback.set(jobid, set);\n    }\n})();\n","import { TypedEmitter } from \"tiny-typed-emitter\";\n\nimport { TokenResponse } from \"../generatedcode/schemas\";\n\ninterface IEvents {\n    //tasks once the user is fully logged in\n    loginSuccess: (token: TokenResponse) => void;\n}\n\nclass LoginHooks extends TypedEmitter<IEvents> {\n    private promiseHooks: Set<(token: TokenResponse) => Promise<unknown>> = new Set();\n\n    public runHooks(token: TokenResponse) {\n        console.log(\"Running login hooks\");\n        let i = 0;\n        const work: Array<Promise<void>> = [];\n        for (const hook of this.promiseHooks) {\n            const id = i;\n            console.log(`Running hook ${hook.name}(${id})`);\n            work.push(\n                new Promise<void>((resolve, reject) => {\n                    hook(token)\n                        .then(() => {\n                            console.log(`Done hook ${hook.name}(${id})`);\n                            resolve();\n                        })\n                        .catch(err => {\n                            console.error(`Error running hook ${hook.name}(${id}): `, err);\n                            reject(err);\n                        });\n                })\n            );\n            i++;\n        }\n        Promise.all(work)\n            .then(() => {\n                console.log(\"Running post login event\");\n                this.emit(\"loginSuccess\", token);\n            })\n            .catch(() => console.error(\"An error occured while running login hooks\"));\n    }\n\n    public addHook(hook: (token: TokenResponse) => Promise<unknown>): void {\n        this.promiseHooks.add(hook);\n    }\n\n    public removeHook(hook: (token: TokenResponse) => Promise<unknown>): void {\n        this.promiseHooks.delete(hook);\n    }\n}\n\nexport default new LoginHooks();\n","import { DEFAULT_APIPATH, MODE } from \"../../definitions/constants\";\n\nexport type ConfigValue = number | string | boolean;\n\nexport type ConfigOption = BaseConfigOption &\n    (NumConfigOption | StrConfigOption | PwdConfigOption | BoolConfigOption | EnumConfigOption);\n\nexport interface BaseConfigOption {\n    id: string;\n}\n\nexport interface NumConfigOption extends BaseConfigOption {\n    type: \"num\";\n    value: number;\n    min?: number;\n    max?: number;\n    callback?: (oldValue: number, newValue: number) => void;\n}\nexport interface StrConfigOption extends BaseConfigOption {\n    type: \"str\";\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\nexport interface PwdConfigOption extends BaseConfigOption {\n    type: \"pwd\";\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\nexport interface BoolConfigOption extends BaseConfigOption {\n    type: \"bool\";\n    value: boolean;\n    callback?: (oldValue: boolean, newValue: boolean) => void;\n}\nexport interface EnumConfigOption extends BaseConfigOption {\n    type: \"enum\";\n    possibleValues: Record<string, string>;\n    value: string;\n    callback?: (oldValue: string, newValue: string) => void;\n}\n\nexport type ConfigMap = {\n    [key: string]: ConfigOption;\n};\n\nexport enum jobsWidgetOptions {\n    ALWAYS = \"always\",\n    AUTO = \"auto\",\n    NEVER = \"never\"\n}\n\nexport enum InstanceEditSidebar {\n    AUTO = \"auto\",\n    COLLAPSE = \"collapse\",\n    EXPAND = \"expand\"\n}\n\n//https://stackoverflow.com/questions/54598322/how-to-make-typescript-infer-the-keys-of-an-object-but-define-type-of-its-value\n//Infer the keys but restrict the values to a type\nconst asElementTypesConfig = <Type>(elements: {\n    [Property in keyof Type]: ConfigOption;\n}) => elements;\n\nconst configOptions = asElementTypesConfig({\n    githubtoken: {\n        id: \"config.githubtoken\",\n        type: \"pwd\",\n        value: \"\"\n    },\n    apipath: {\n        id: \"config.apipath\",\n        type: \"str\",\n        value: DEFAULT_APIPATH\n    },\n    jobpollinactive: {\n        id: \"config.jobpollinactive\",\n        type: \"num\",\n        value: 15\n    },\n    jobpollactive: {\n        id: \"config.jobpollactive\",\n        type: \"num\",\n        value: 5\n    },\n    jobswidgetdisplay: {\n        id: \"config.jobswidgetdisplay\",\n        type: \"enum\",\n        possibleValues: jobsWidgetOptions,\n        value: jobsWidgetOptions.AUTO\n    },\n    instanceprobetimer: {\n        id: \"config.instanceprobetimer\",\n        type: \"num\",\n        value: 60\n    },\n    itemsperpage: {\n        id: \"config.itemsperpage\",\n        type: \"num\",\n        value: 25,\n        min: 1,\n        max: 100\n    },\n    instanceeditsidebar: {\n        id: \"config.instanceeditsidebar\",\n        type: \"enum\",\n        possibleValues: InstanceEditSidebar,\n        value: InstanceEditSidebar.AUTO\n    },\n    showjson: {\n        id: \"config.showjson\",\n        type: \"bool\",\n        value: MODE === \"DEV\"\n    }\n});\n\nexport default configOptions;\n"],"names":["response","page","pageSize","configOptions","ServerClient","stat","InternalStatus","code","StatusCode","error","status","payload","data","InternalError","ErrorCode","axiosResponse","instance","this","emit","id","errorMessage","instanceid","ApiClient","_cachedInstancePermissionSet","Map","loadingInstancePermissionSetInfo","clear","has","get","Promise","resolve","on","resolver","user","removeListener","set","Instance","res","newContent","content","map","job","jobid","void","apiClient","api","initialized","loadingServerInfo","_serverInfo","autoLogin","loggingIn","getServerInfo","bind","LoginHooks","undefined","CredentialsProvider","console","log","initApi","then","catch","window","location","reload","time","defObj","default","OpenAPIClientAxios","definition","axiosConfigDefaults","baseURL","withCredentials","headers","Accept","Api","API_VERSION","VERSION","validateStatus","globalHandledCodes","includes","init","interceptors","request","use","value","errorobj","reject","url","tok","wait4Token","bearer","val","snowflake","err","jsError","config","method","login","client","logout","setTimeout","timeEnd","token","newCreds","wait4Init","oauthAutoLogin","type","CredentialsType","info","HomeController_CreateToken","OAuthProvider","auth","username","password","Authorization","_token","bypassCache","HomeController_Home","cache","_cachedUser","loadingUserInfo","createAllUsersWithAA","getCurrentUser","newUser","current","thing","sort","a","b","newuser","enabled","instanceManagerRights","administrationRights","Object","values","InstanceManagerRights","perm","AdministrationRights","clients","constructor","name","TypedEmitter","ByondRights","ChatBotRights","ChatProvider","ConfigurationRights","ConfigurationType","DreamDaemonRights","DreamDaemonSecurity","DreamDaemonVisibility","DreamMakerRights","InstancePermissionSetRights","RemoteGitProvider","RepositoryRights","RightsType","WatchdogStatus","DescType","addon","origin","desc","extendedInfo","originalErrorMessage","TEXT","TGSErrorCode","errorCode","message","additionalData","stack","Error","debuginfo","JSON","stringify","replace","replaceAll","breakonerror","args","freeze","assign","getconfig","newconfig","entries","key","setconfig","option","deleteconfig","parseInt","Number","isNaN","min","max","callback","localStorage","setItem","e","getItem","json","parse","removeItem","credentials","fastmodecount","currentLoop","Date","accessibleInstances","Set","enableJobProgressWorkaround","errors","jobs","jobsByInstance","jobCallback","loop","reset","restartLoop","cycles","reloadAccessibleInstances","push","InstanceClient","SemverSatisfies","version","allInstances","instances1","i","totalPages","instances2","updatedSet","work","filter","online","InstancePermissionSetClient","permissionSet","add","all","initDate","now","loopid","totalActiveJobs","forEach","processJobs","instanceSet","remoteActive","manualIds","Array","from","stoppedAt","jobId","JobsClient","length","processError","delete","jobs2","reason","progress","progressedjob","canCancel","callbacks","cancelRightsType","userInfo","UserClient","required","cancelRight","resolvePermissionSet","InstancePermissionSet","byondRights","chatBotRights","configurationRights","dreamDaemonRights","dreamMakerRights","instancePermissionSetRights","repositoryRights","onError","deleteInfo","promiseHooks","hook","jobsWidgetOptions","InstanceEditSidebar","githubtoken","apipath","DEFAULT_APIPATH","jobpollinactive","jobpollactive","jobswidgetdisplay","possibleValues","AUTO","instanceprobetimer","itemsperpage","instanceeditsidebar","showjson","MODE"],"sourceRoot":""}